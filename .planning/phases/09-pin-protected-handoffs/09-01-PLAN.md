---
phase: 09-pin-protected-handoffs
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/crypto/mod.rs
  - src/record/mod.rs
autonomous: true
requirements:
  - SEC-03

must_haves:
  truths:
    - "A PIN and salt deterministically produce the same 32-byte key via Argon2id+HKDF"
    - "Plaintext encrypted with a PIN-derived key can be decrypted with the same PIN and salt"
    - "Decryption with the wrong PIN fails with an error (not a panic or silent wrong result)"
    - "Decryption with the owner's keypair alone fails for PIN-encrypted data"
    - "The pin_salt field is included in the signed envelope (HandoffRecordSignable)"
  artifacts:
    - path: "src/crypto/mod.rs"
      provides: "PIN key derivation and PIN-based encrypt/decrypt functions"
      exports: ["pin_derive_key", "pin_encrypt", "pin_decrypt"]
    - path: "src/record/mod.rs"
      provides: "pin_salt field in HandoffRecord and HandoffRecordSignable"
      contains: "pin_salt"
    - path: "Cargo.toml"
      provides: "argon2 and hkdf+sha2 dependencies"
      contains: "argon2"
  key_links:
    - from: "src/crypto/mod.rs"
      to: "argon2 crate"
      via: "Argon2id::default().hash_password_into()"
      pattern: "argon2.*Argon2id"
    - from: "src/crypto/mod.rs"
      to: "hkdf crate"
      via: "Hkdf::<Sha256>::new()"
      pattern: "hkdf.*Hkdf"
    - from: "src/crypto/mod.rs"
      to: "age encryption"
      via: "age_encrypt with PIN-derived recipient"
      pattern: "age_encrypt.*age_recipient"
    - from: "src/record/mod.rs"
      to: "src/record/mod.rs"
      via: "pin_salt in HandoffRecordSignable alphabetical field order"
      pattern: "pin_salt"
---

<objective>
Implement PIN-based key derivation using Argon2id+HKDF and add PIN encryption/decryption functions to the crypto module. Add pin_salt field to handoff record structs.

Purpose: Provides the cryptographic foundation for PIN-protected handoffs. The PIN-derived key replaces the owner's keypair as the encryption recipient, ensuring only someone who knows the PIN can decrypt.

Output: Working, tested PIN key derivation and encrypt/decrypt functions; updated HandoffRecord with pin_salt field.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/crypto/mod.rs
@src/record/mod.rs
@Cargo.toml
@tests/integration_round_trip.rs
</context>

<feature>
  <name>PIN-based key derivation and encryption</name>
  <files>Cargo.toml, src/crypto/mod.rs, src/record/mod.rs</files>
  <behavior>
    PIN key derivation:
    - pin_derive_key("1234", salt_bytes) -> deterministic [u8; 32]
    - Same PIN + same salt -> same key (deterministic)
    - Different PIN + same salt -> different key
    - Uses Argon2id with sensible parameters (t=3, m=65536, p=1) then HKDF-SHA256 expand with info="cclink-pin-v1"

    PIN encryption (wraps existing age encryption):
    - pin_encrypt(plaintext, pin) -> (ciphertext_blob: Vec<u8>, salt: [u8; 32])
    - Generates random 32-byte salt
    - Derives X25519 secret key from PIN via Argon2id+HKDF
    - Derives corresponding X25519 public key (multiply by base point)
    - Constructs age Recipient from derived public key
    - Encrypts plaintext with age_encrypt to the derived Recipient
    - Returns (age_ciphertext, salt)

    PIN decryption:
    - pin_decrypt(ciphertext, pin, salt) -> plaintext bytes
    - Re-derives X25519 secret key from PIN+salt via Argon2id+HKDF
    - Constructs age Identity from derived secret key
    - Decrypts with age_decrypt using the derived Identity
    - Wrong PIN produces age decryption error (not a panic)

    Record field:
    - HandoffRecord gains `pin_salt: Option<String>` (base64-encoded salt, None when no PIN used)
    - HandoffRecordSignable gains `pin_salt: Option<String>` (signed into envelope)
    - Field position: alphabetical between `project` and `pubkey`
    - From<&HandoffRecord> for HandoffRecordSignable copies pin_salt

    Cases:
    - pin_derive_key("1234", [1u8;32]) -> [u8; 32] (deterministic, not all-zeros)
    - pin_derive_key("1234", [1u8;32]) == pin_derive_key("1234", [1u8;32]) (same inputs -> same output)
    - pin_derive_key("1234", [1u8;32]) != pin_derive_key("5678", [1u8;32]) (different PIN -> different key)
    - pin_encrypt(b"session-id", "1234") -> (blob, salt) where blob is non-empty
    - pin_decrypt(blob, "1234", salt) -> b"session-id" (round-trip)
    - pin_decrypt(blob, "9999", salt) -> Err (wrong PIN)
    - age_decrypt(blob, owner_identity) -> Err (owner keypair alone cannot decrypt PIN-protected data)
  </behavior>
  <implementation>
    **Dependencies (Cargo.toml):**
    Add `argon2 = "0.5"` and `hkdf = "0.12"` and `sha2 = "0.10"` to [dependencies].
    Also add `rand = "0.8"` for generating random salt (or use existing mechanism if available).

    **Crypto module (src/crypto/mod.rs):**

    1. `pin_derive_key(pin: &str, salt: &[u8; 32]) -> anyhow::Result<[u8; 32]>`:
       - Create Argon2id instance with params: t_cost=3, m_cost=65536 (64MB), p_cost=1
       - Hash: `argon2.hash_password_into(pin.as_bytes(), salt, &mut output_32)` where output_32 is [u8; 32]
       - Expand via HKDF-SHA256: `Hkdf::<Sha256>::new(None, &output_32)` then `.expand(b"cclink-pin-v1", &mut okm_32)`
       - Return okm_32

    2. `pin_encrypt(plaintext: &[u8], pin: &str) -> anyhow::Result<(Vec<u8>, [u8; 32])>`:
       - Generate 32-byte random salt: `rand::thread_rng().gen::<[u8; 32]>()`
       - Call `pin_derive_key(pin, &salt)` to get derived_key
       - Construct age Identity from derived_key: `age_identity(&derived_key)`
       - Get public key from identity: `identity.to_public()` returns age::x25519::Recipient
       - Call `age_encrypt(plaintext, &recipient)` to encrypt
       - Return (ciphertext, salt)

    3. `pin_decrypt(ciphertext: &[u8], pin: &str, salt: &[u8; 32]) -> anyhow::Result<Vec<u8>>`:
       - Call `pin_derive_key(pin, salt)` to get derived_key
       - Construct age Identity: `age_identity(&derived_key)`
       - Call `age_decrypt(ciphertext, &identity)`
       - Return plaintext (or propagate age decryption error on wrong PIN)

    **Record module (src/record/mod.rs):**

    1. Add `pin_salt: Option<String>` to HandoffRecord between `project` and `pubkey` (alphabetical order):
       - `#[serde(default)]` for backwards compat with records that don't have it
       - Field position after `project`, before `pubkey`

    2. Add `pin_salt: Option<String>` to HandoffRecordSignable in same alphabetical position:
       - Between `project` and `pubkey`

    3. Update `From<&HandoffRecord> for HandoffRecordSignable` to copy pin_salt.

    4. Update ALL existing test helpers (sample_signable, HandoffRecord constructions) to include `pin_salt: None`.

    **Key design note:** The Argon2id output is used as the raw X25519 scalar bytes for age_identity(). This works because age_identity() takes arbitrary [u8; 32] and bech32-encodes it into an age Identity string. The HKDF expansion step ensures the key is in the right domain even if Argon2id output has bias.
  </implementation>
</feature>

<verification>
1. `cargo test` — all existing tests pass (no regressions from pin_salt: None additions)
2. `cargo test pin` — all new PIN-specific tests pass:
   - pin_derive_key deterministic
   - pin_derive_key different PINs produce different keys
   - pin_encrypt/pin_decrypt round-trip
   - pin_decrypt with wrong PIN fails
   - Owner keypair cannot decrypt PIN-encrypted data
3. `cargo build` — compiles with zero warnings
4. Record serialization tests pass with pin_salt field in correct alphabetical position
</verification>

<success_criteria>
- pin_derive_key produces deterministic 32-byte keys from PIN+salt via Argon2id+HKDF
- pin_encrypt/pin_decrypt round-trip succeeds
- Wrong PIN produces a clear error on decrypt
- Owner's X25519 identity cannot decrypt PIN-encrypted data
- HandoffRecord and HandoffRecordSignable include pin_salt in signed envelope
- All existing tests pass unchanged (pin_salt defaults to None)
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/09-pin-protected-handoffs/09-01-SUMMARY.md`
</output>
