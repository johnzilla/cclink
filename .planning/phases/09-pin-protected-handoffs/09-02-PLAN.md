---
phase: 09-pin-protected-handoffs
plan: 02
type: execute
wave: 2
depends_on:
  - 09-01
files_modified:
  - src/cli.rs
  - src/commands/publish.rs
  - src/commands/pickup.rs
  - tests/integration_round_trip.rs
autonomous: true
requirements:
  - SEC-03

must_haves:
  truths:
    - "Running cclink --pin prompts for a PIN and publishes a record encrypted with a PIN-derived key"
    - "Running cclink pickup on a PIN-protected record prompts for the PIN before decryption succeeds"
    - "Providing the wrong PIN during pickup produces a clear decryption failure error"
    - "A PIN-protected record stores pin_salt in the published JSON (non-null, base64-encoded)"
    - "--pin and --share are mutually exclusive (CLI errors if both specified)"
  artifacts:
    - path: "src/cli.rs"
      provides: "--pin flag on Cli struct"
      contains: "pin"
    - path: "src/commands/publish.rs"
      provides: "PIN prompt and pin_encrypt call in publish flow"
      contains: "pin_encrypt"
    - path: "src/commands/pickup.rs"
      provides: "PIN detection (pin_salt present) and pin_decrypt call in pickup flow"
      contains: "pin_decrypt"
    - path: "tests/integration_round_trip.rs"
      provides: "Integration test for PIN-protected handoff round-trip"
      contains: "test_pin_encrypt_round_trip"
  key_links:
    - from: "src/commands/publish.rs"
      to: "src/crypto/mod.rs"
      via: "pin_encrypt() call when --pin flag is set"
      pattern: "crate::crypto::pin_encrypt"
    - from: "src/commands/pickup.rs"
      to: "src/crypto/mod.rs"
      via: "pin_decrypt() call when pin_salt is present in record"
      pattern: "crate::crypto::pin_decrypt"
    - from: "src/cli.rs"
      to: "src/commands/publish.rs"
      via: "cli.pin flag drives encryption path selection"
      pattern: "cli\\.pin"
    - from: "src/commands/pickup.rs"
      to: "record.pin_salt"
      via: "pin_salt.is_some() detection triggers PIN prompt"
      pattern: "record\\.pin_salt.*is_some"
---

<objective>
Wire PIN-based encryption into the CLI, publish, and pickup flows. Add --pin flag, PIN prompting, and integrate pin_encrypt/pin_decrypt from the crypto module.

Purpose: Completes the user-facing PIN-protected handoff feature. Users can publish with --pin and pick up by entering the PIN when prompted.

Output: Working end-to-end --pin flow with integration tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pin-protected-handoffs/09-01-SUMMARY.md
@src/cli.rs
@src/commands/publish.rs
@src/commands/pickup.rs
@src/crypto/mod.rs
@src/record/mod.rs
@tests/integration_round_trip.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --pin CLI flag and wire publish flow</name>
  <files>src/cli.rs, src/commands/publish.rs</files>
  <action>
    **src/cli.rs:**
    Add `--pin` flag to the `Cli` struct:
    ```rust
    /// Protect handoff with a PIN (prompts for PIN at publish time)
    #[arg(long, conflicts_with = "share")]
    pub pin: bool,
    ```
    The `conflicts_with = "share"` ensures --pin and --share are mutually exclusive at parse time (same pattern as --burn/--share). --pin and --burn CAN be combined (burn-after-read PIN-protected record is valid).

    **src/commands/publish.rs:**
    Modify section 4 (encrypt session ID) to handle the --pin case:

    1. After the existing `let recipient = if let Some(ref share_pubkey) ...` block, add a new branch for `--pin`:

    ```rust
    let (blob, pin_salt_value) = if cli.pin {
        // PIN-protected: prompt for PIN, encrypt with PIN-derived key
        let pin = dialoguer::Password::new()
            .with_prompt("Enter PIN for this handoff")
            .with_confirmation("Confirm PIN", "PINs don't match")
            .interact()
            .map_err(|e| anyhow::anyhow!("PIN prompt failed: {}", e))?;

        let (ciphertext, salt) = crate::crypto::pin_encrypt(session.session_id.as_bytes(), &pin)?;
        let blob = base64::engine::general_purpose::STANDARD.encode(&ciphertext);
        let salt_b64 = base64::engine::general_purpose::STANDARD.encode(salt);
        (blob, Some(salt_b64))
    } else {
        // Existing path: age encrypt to recipient (self or --share)
        let recipient = if let Some(ref share_pubkey) = cli.share {
            crate::crypto::recipient_from_z32(share_pubkey)?
        } else {
            let x25519_pubkey = crate::crypto::ed25519_to_x25519_public(&keypair);
            crate::crypto::age_recipient(&x25519_pubkey)
        };
        let ciphertext = crate::crypto::age_encrypt(session.session_id.as_bytes(), &recipient)?;
        let blob = base64::engine::general_purpose::STANDARD.encode(&ciphertext);
        (blob, None)
    };
    ```

    2. Update the HandoffRecordSignable and HandoffRecord construction to include `pin_salt: pin_salt_value.clone()` in the correct alphabetical position (between `project` and `pubkey`).

    3. In output section 7, add a note when --pin is used:
    ```rust
    if cli.pin {
        println!(
            "{}",
            "PIN-protected: recipient must enter the PIN to decrypt."
                .if_supports_color(Stdout, |t| t.yellow())
        );
    }
    ```

    4. Use `dialoguer::Password` for PIN input (already have dialoguer 0.12 in Cargo.toml). The Password widget hides input and supports confirmation. Do NOT use `dialoguer::Input` — PINs should not echo to terminal.
  </action>
  <verify>
    `cargo build` compiles with zero warnings. `cclink --pin --share abc` errors at parse time with conflict message. `cclink --help` shows --pin flag.
  </verify>
  <done>
    --pin flag exists in CLI, publish.rs prompts for PIN and calls pin_encrypt when --pin is set, pin_salt is populated in the record, --pin/--share are mutually exclusive.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pickup flow for PIN-protected records and add integration tests</name>
  <files>src/commands/pickup.rs, tests/integration_round_trip.rs</files>
  <action>
    **src/commands/pickup.rs:**

    Modify section 4 (Decrypt or show metadata) to detect and handle PIN-protected records:

    1. Before the existing `if is_cross_user` block, add PIN detection:
    ```rust
    // ── PIN-protected record detection ────────────────────────────────
    if let Some(ref pin_salt_b64) = record.pin_salt {
        // PIN-protected record: prompt for PIN and decrypt
        let salt_bytes = base64::engine::general_purpose::STANDARD
            .decode(pin_salt_b64)
            .map_err(|e| anyhow::anyhow!("invalid pin_salt base64: {}", e))?;
        let salt: [u8; 32] = salt_bytes
            .try_into()
            .map_err(|_| anyhow::anyhow!("pin_salt must be exactly 32 bytes"))?;

        let ciphertext = base64::engine::general_purpose::STANDARD
            .decode(&record.blob)
            .map_err(|e| anyhow::anyhow!("failed to decode blob: {}", e))?;

        let pin = dialoguer::Password::new()
            .with_prompt("Enter PIN")
            .interact()
            .map_err(|e| anyhow::anyhow!("PIN prompt failed: {}", e))?;

        match crate::crypto::pin_decrypt(&ciphertext, &pin, &salt) {
            Ok(plaintext) => {
                session_id = String::from_utf8(plaintext)
                    .map_err(|e| anyhow::anyhow!("session ID is not valid UTF-8: {}", e))?;
            }
            Err(_) => {
                eprintln!(
                    "{}",
                    "Error: Incorrect PIN. Cannot decrypt this handoff."
                        .if_supports_color(Stdout, |t| t.red())
                );
                anyhow::bail!("Incorrect PIN — decryption failed");
            }
        }
    } else if is_cross_user {
        // ... existing cross-user path ...
    ```

    2. The PIN path should work for both self-pickup and cross-user pickup. If pin_salt is present, PIN decryption takes priority regardless of whether a pubkey arg was given. This is because PIN-protected records are encrypted to a PIN-derived key, not the owner's key.

    3. The PIN prompt on pickup does NOT use confirmation (single entry, not double). Only publish uses confirmation prompt.

    4. The burn-after-read logic (section 5) remains unchanged — it fires after successful decryption regardless of whether PIN was used.

    5. For non-interactive mode (stdin not a terminal): if pin_salt is present and stdin is not a terminal, bail with a clear error: "PIN-protected handoff requires interactive terminal for PIN entry".

    **tests/integration_round_trip.rs:**

    Add two new integration tests:

    Test 7: `test_pin_encrypt_round_trip`:
    - Use pin_encrypt to encrypt a session ID with PIN "1234"
    - Use pin_decrypt with same PIN and returned salt to decrypt
    - Assert plaintext matches original
    - Use pin_decrypt with wrong PIN "9999" and assert Err

    Test 8: `test_pin_record_owner_cannot_decrypt`:
    - Use pin_encrypt to encrypt a session ID with PIN "5678"
    - Try age_decrypt with owner's keypair identity
    - Assert Err — proves owner keypair alone cannot decrypt PIN-protected data
    - Then use pin_decrypt with correct PIN and assert success

    Add the necessary imports: `use cclink::crypto::{pin_encrypt, pin_decrypt};`
  </action>
  <verify>
    `cargo test` — all tests pass (existing + new PIN tests). `cargo build` — zero warnings. New tests specifically verify: round-trip with correct PIN, failure with wrong PIN, owner keypair cannot decrypt PIN-protected data.
  </verify>
  <done>
    Pickup detects PIN-protected records via pin_salt field, prompts for PIN, decrypts with pin_decrypt. Wrong PIN shows clear error "Incorrect PIN". Integration tests prove round-trip and security properties.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` — all tests pass (unit + integration, existing + new)
2. `cargo build` — zero compiler warnings
3. `cclink --help` shows --pin flag with description
4. `cclink --pin --share abc` errors at parse time
5. `cclink --pin --burn` is allowed (no conflict)
6. Integration test `test_pin_encrypt_round_trip` proves correct PIN decrypts, wrong PIN fails
7. Integration test `test_pin_record_owner_cannot_decrypt` proves keypair alone is insufficient
</verification>

<success_criteria>
- `cclink --pin` prompts for PIN (with confirmation) and publishes PIN-protected record
- PIN-protected record has non-null pin_salt in JSON
- `cclink pickup` on PIN-protected record prompts for PIN (single entry, no confirmation)
- Correct PIN decrypts successfully; wrong PIN shows "Incorrect PIN" error
- Owner's keypair alone cannot decrypt PIN-protected data
- --pin and --share are mutually exclusive at parse time
- All existing and new tests pass with zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/09-pin-protected-handoffs/09-02-SUMMARY.md`
</output>
