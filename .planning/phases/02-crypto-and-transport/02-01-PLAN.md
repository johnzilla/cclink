---
phase: 02-crypto-and-transport
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/crypto/mod.rs
  - src/main.rs
autonomous: true
requirements:
  - PUB-03

must_haves:
  truths:
    - "Ed25519 keypair from Phase 1 can derive a valid X25519 secret scalar and public Montgomery point"
    - "A plaintext session ID encrypted with the derived X25519 recipient key can be decrypted by the corresponding X25519 identity key"
    - "age ciphertext round-trips correctly (encrypt then decrypt yields identical plaintext)"
  artifacts:
    - path: "Cargo.toml"
      provides: "All Phase 2 dependencies"
      contains: "age"
    - path: "src/crypto/mod.rs"
      provides: "Key derivation + age encrypt/decrypt"
      exports: ["ed25519_to_x25519_secret", "ed25519_to_x25519_public", "age_identity", "age_recipient", "age_encrypt", "age_decrypt"]
  key_links:
    - from: "src/crypto/mod.rs"
      to: "pkarr::Keypair"
      via: "keypair.secret_key() -> SigningKey -> to_scalar_bytes()"
      pattern: "to_scalar_bytes"
    - from: "src/crypto/mod.rs"
      to: "age::x25519::Identity"
      via: "bech32 encode of X25519 scalar bytes"
      pattern: "bech32::encode.*age-secret-key"
---

<objective>
Add all Phase 2 dependencies to Cargo.toml and implement the crypto module with Ed25519-to-X25519 key derivation and age encryption/decryption.

Purpose: PUB-03 requires session IDs to be age-encrypted to the creator's own X25519 key derived from their Ed25519 keypair. This plan builds the foundational crypto layer that the record and transport modules depend on.
Output: Working `src/crypto/mod.rs` with tested key derivation and age round-trip encryption.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-crypto-and-transport/02-RESEARCH.md
@src/keys/store.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add all Phase 2 dependencies to Cargo.toml</name>
  <files>Cargo.toml</files>
  <action>
Add ALL Phase 2 dependencies to Cargo.toml in a single step (so later plans don't need to touch Cargo.toml):

```toml
age = "0.11"
reqwest = { version = "0.13", default-features = false, features = ["blocking", "cookies", "rustls-tls"] }
postcard = { version = "1", features = ["alloc"] }
bech32 = "0.9"
base64 = "0.22"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
gethostname = "0.5"
```

Notes:
- `serde` and `serde_json` are needed by the record module (Plan 02) for HandoffRecord serialization.
- `reqwest`, `postcard` are needed by the transport module (Plan 03) for homeserver communication.
- `base64` is needed by record module (Plan 02) for signature encoding.
- `gethostname` is needed by record module (Plan 02) for the hostname metadata field.
- `bech32` and `age` are needed by this plan's crypto module.
- Do NOT add `ed25519-dalek` directly -- it's already a transitive dependency via pkarr 5.0.3.

Run `cargo check` to verify all dependencies resolve without conflicts. The age crate uses curve25519-dalek 4 while pkarr uses curve25519-dalek 5.0.0-pre.6 -- these coexist as separate semver-incompatible crates (confirmed in research). Never pass types between them; always convert via raw `[u8; 32]` bytes.
  </action>
  <verify>`cargo check` passes with no errors</verify>
  <done>All Phase 2 dependencies compile successfully alongside existing Phase 1 dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Implement crypto module with TDD (key derivation + age encrypt/decrypt)</name>
  <files>src/crypto/mod.rs, src/main.rs</files>
  <action>
**RED phase:** Create `src/crypto/mod.rs` with function signatures and `#[cfg(test)] mod tests`. Write tests FIRST:

1. `test_ed25519_to_x25519_secret_deterministic` -- same keypair always produces same 32-byte scalar
2. `test_ed25519_to_x25519_public_deterministic` -- same keypair always produces same 32-byte Montgomery point
3. `test_age_encrypt_decrypt_round_trip` -- encrypt "session-abc123" with derived recipient, decrypt with derived identity, assert plaintext matches
4. `test_age_encrypt_produces_different_ciphertext` -- two encryptions of same plaintext produce different ciphertext (age uses ephemeral keys)
5. `test_age_decrypt_wrong_key_fails` -- encrypt with key A, try decrypt with key B, assert error

Add `mod crypto;` to `src/main.rs`.

Run tests -- they MUST fail (RED).

**GREEN phase:** Implement the following public functions:

```rust
pub fn ed25519_to_x25519_secret(keypair: &pkarr::Keypair) -> [u8; 32]
```
- `keypair.secret_key()` returns `[u8; 32]` (raw Ed25519 seed)
- Reconstruct `ed25519_dalek::SigningKey::from_bytes(&keypair.secret_key())`
- Call `signing_key.to_scalar_bytes()` which returns SHA-512(seed)[0..32]
- Return the 32-byte scalar

```rust
pub fn ed25519_to_x25519_public(keypair: &pkarr::Keypair) -> [u8; 32]
```
- `keypair.public_key().verifying_key().to_montgomery().to_bytes()`
- This uses curve25519-dalek 5 (pkarr's version) -- that's fine, we only extract raw bytes

```rust
pub fn age_identity(x25519_secret: &[u8; 32]) -> age::x25519::Identity
```
- Bech32-encode with HRP "age-secret-key-" using `bech32::encode("age-secret-key-", secret.to_base32(), Variant::Bech32)`
- Convert to uppercase: `.to_ascii_uppercase()`
- Parse: `.parse::<age::x25519::Identity>().expect("valid age identity")`

```rust
pub fn age_recipient(x25519_pubkey: &[u8; 32]) -> age::x25519::Recipient
```
- Bech32-encode with HRP "age" using `bech32::encode("age", pubkey.to_base32(), Variant::Bech32)`
- Parse: `.parse::<age::x25519::Recipient>().expect("valid age recipient")`

```rust
pub fn age_encrypt(plaintext: &[u8], recipient: &age::x25519::Recipient) -> anyhow::Result<Vec<u8>>
```
- `Encryptor::with_recipients(std::iter::once(recipient as &dyn age::Recipient))`
- `wrap_output(&mut ciphertext)` -> `write_all(plaintext)` -> `finish()`
- Return full ciphertext (includes age header -- do NOT strip it)

```rust
pub fn age_decrypt(ciphertext: &[u8], identity: &age::x25519::Identity) -> anyhow::Result<Vec<u8>>
```
- `age::Decryptor::new(ciphertext)` -> `decrypt(std::iter::once(identity as &dyn age::Identity))`
- Read all into Vec<u8>
- Return plaintext

Run tests -- they MUST pass (GREEN).

**REFACTOR:** If needed, clean up. Ensure all functions are `pub` and well-documented. No unnecessary unwraps -- use `anyhow::Result` for fallible operations.
  </action>
  <verify>`cargo test --lib crypto` -- all 5 tests pass. `cargo check` clean.</verify>
  <done>Key derivation produces valid X25519 keys from Ed25519 keypairs, and age encrypt/decrypt round-trips correctly for arbitrary plaintext</done>
</task>

</tasks>

<verification>
1. `cargo check` -- project compiles with all new dependencies
2. `cargo test --lib crypto` -- all crypto tests pass
3. Verify age ciphertext includes header (not just raw encrypted bytes) by checking ciphertext starts with `age-encryption.org`
</verification>

<success_criteria>
- All Phase 2 dependencies added and compiling
- `ed25519_to_x25519_secret` and `ed25519_to_x25519_public` produce deterministic 32-byte outputs
- age encrypt/decrypt round-trip works for arbitrary plaintext
- Different encryptions produce different ciphertext (ephemeral key randomness)
- Decryption with wrong key fails with error
</success_criteria>

<output>
After completion, create `.planning/phases/02-crypto-and-transport/02-01-SUMMARY.md`
</output>
