---
phase: 02-crypto-and-transport
plan: 02
type: tdd
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/record/mod.rs
  - src/error.rs
autonomous: true
requirements:
  - PUB-02
  - UX-02

must_haves:
  truths:
    - "A HandoffRecord can be constructed with hostname, project path, created_at timestamp, TTL, encrypted blob, and creator pubkey"
    - "HandoffRecord serializes to canonical JSON with deterministic key ordering (alphabetical, no whitespace)"
    - "An Ed25519 signature over canonical JSON can be computed and verified in a round-trip"
    - "Verification with a wrong public key or tampered JSON fails with an error"
    - "The signature field is excluded from the canonical JSON used for signing (preventing circular dependency)"
  artifacts:
    - path: "src/record/mod.rs"
      provides: "HandoffRecord struct, canonical JSON, Ed25519 signing and verification"
      exports: ["HandoffRecord", "HandoffRecordSignable", "LatestPointer", "canonical_json", "sign_record", "verify_record"]
    - path: "src/error.rs"
      provides: "Extended error enum with crypto/record variants"
      contains: "SignatureVerificationFailed"
  key_links:
    - from: "src/record/mod.rs"
      to: "pkarr::Keypair"
      via: "keypair.sign(canonical_json_bytes)"
      pattern: "keypair\\.sign"
    - from: "src/record/mod.rs"
      to: "pkarr::PublicKey"
      via: "pubkey.verify(canonical_json_bytes, &signature)"
      pattern: "verify.*canonical"
    - from: "src/record/mod.rs"
      to: "serde_json"
      via: "serde_json::to_string for canonical compact JSON"
      pattern: "serde_json::to_string"
---

<objective>
Implement the HandoffRecord struct with JSON serialization, canonical JSON for deterministic signing, and Ed25519 signature creation/verification.

Purpose: PUB-02 requires handoff records to include hostname, project path, timestamp, and TTL. UX-02 requires Ed25519 signature verification on all retrieved records. This plan builds the record data model and signing infrastructure.
Output: Working `src/record/mod.rs` with tested HandoffRecord serialization and signature round-trip.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-crypto-and-transport/02-RESEARCH.md
@.planning/phases/02-crypto-and-transport/02-01-SUMMARY.md
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement HandoffRecord and LatestPointer structs with canonical JSON and signing (TDD)</name>
  <files>src/record/mod.rs, src/error.rs</files>
  <action>
**Extend error types first** -- add to `src/error.rs`:

```rust
#[error("Signature verification failed: {0}")]
SignatureVerificationFailed(String),

#[error("Record deserialization failed: {0}")]
RecordDeserializationFailed(String),
```

**RED phase:** Create `src/record/mod.rs` with struct definitions and `#[cfg(test)] mod tests`. Write tests FIRST:

1. `test_handoff_record_signable_serializes_alphabetical_keys` -- create a HandoffRecordSignable, serialize to JSON, verify keys appear in alphabetical order: blob, created_at, hostname, project, pubkey, ttl
2. `test_canonical_json_is_compact_no_whitespace` -- canonical JSON has no spaces or newlines
3. `test_canonical_json_deterministic` -- same struct serializes to identical JSON bytes every time (call twice, assert equal)
4. `test_sign_and_verify_round_trip` -- create a record, sign it, verify signature passes
5. `test_verify_fails_wrong_pubkey` -- sign with key A, verify with key B's pubkey, assert SignatureVerificationFailed
6. `test_verify_fails_tampered_json` -- sign record, modify a field (e.g., TTL), verify fails
7. `test_latest_pointer_serialization` -- LatestPointer serializes/deserializes correctly with token, project, hostname, created_at fields

Add `mod record;` to `src/main.rs`.

Run tests -- they MUST fail (RED).

**GREEN phase:** Implement:

```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HandoffRecord {
    pub blob: String,         // base64-encoded age ciphertext
    pub created_at: u64,      // Unix timestamp seconds
    pub hostname: String,
    pub project: String,
    pub pubkey: String,       // creator's z32 public key
    pub signature: String,    // base64 Ed25519 sig over canonical JSON of signable fields
    pub ttl: u64,             // seconds
}
```

Fields are ALPHABETICALLY ordered in the struct definition. This is critical because serde serializes struct fields in declaration order, and serde_json's default map is BTreeMap (sorted). With alphabetical struct field order, serialization is deterministic. Do NOT enable the `preserve_order` feature on serde_json.

```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct HandoffRecordSignable {
    pub blob: String,
    pub created_at: u64,
    pub hostname: String,
    pub project: String,
    pub pubkey: String,
    pub ttl: u64,
}
```

Same alphabetical ordering, minus `signature`.

```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct LatestPointer {
    pub created_at: u64,
    pub hostname: String,
    pub project: String,
    pub token: String,        // Unix timestamp token matching record path
}
```

Per user decision: latest.json contains token + summary metadata (project, hostname, created_at).

Implement conversion: `impl From<&HandoffRecord> for HandoffRecordSignable` -- copies all fields except signature.

```rust
pub fn canonical_json(signable: &HandoffRecordSignable) -> anyhow::Result<String>
```
- `serde_json::to_string(signable)` -- compact JSON, no whitespace (to_string, not to_string_pretty)
- serde_json with default features serializes struct fields in declaration order -- since fields are alphabetical, this is canonical

```rust
pub fn sign_record(signable: &HandoffRecordSignable, keypair: &pkarr::Keypair) -> anyhow::Result<String>
```
- Get canonical JSON bytes
- `keypair.sign(canonical_json.as_bytes())` returns `ed25519_dalek::Signature`
- `base64::engine::general_purpose::STANDARD.encode(sig.to_bytes())` -- base64 encode the 64-byte signature
- Return the base64 string

```rust
pub fn verify_record(record: &HandoffRecord, pubkey: &pkarr::PublicKey) -> anyhow::Result<()>
```
- Extract signable from record (via `HandoffRecordSignable::from(record)`)
- Get canonical JSON
- Decode `record.signature` from base64 to 64 bytes
- Construct `ed25519_dalek::Signature::from_bytes(bytes.try_into()?)` -- NOTE: from_bytes takes `&[u8; 64]`
- `pubkey.verify(canonical_json.as_bytes(), &sig)` -- this uses pkarr's verify which wraps ed25519-dalek
- On failure: return `CclinkError::SignatureVerificationFailed`

Per user decision: Hard fail on verification failure. No bypass flag.

Run tests -- they MUST pass (GREEN).

**REFACTOR:** Clean up, add doc comments on all public items.
  </action>
  <verify>`cargo test --lib record` -- all 7 tests pass. `cargo check` clean.</verify>
  <done>HandoffRecord serializes to deterministic canonical JSON, Ed25519 signatures round-trip correctly, verification rejects tampered records and wrong keys, and LatestPointer serializes correctly</done>
</task>

</tasks>

<verification>
1. `cargo test --lib record` -- all record tests pass
2. `cargo check` -- project compiles clean
3. Verify canonical JSON key order by inspecting test output: keys must be alphabetical
4. Verify signature is base64-encoded 64-byte Ed25519 signature
</verification>

<success_criteria>
- HandoffRecord has all required metadata fields (hostname, project, created_at, ttl, pubkey, blob, signature)
- Canonical JSON produces identical bytes for identical inputs with alphabetically sorted keys
- Sign + verify round-trip succeeds
- Verification rejects wrong public key
- Verification rejects tampered record content
- LatestPointer struct serializes with token, project, hostname, created_at
</success_criteria>

<output>
After completion, create `.planning/phases/02-crypto-and-transport/02-02-SUMMARY.md`
</output>
