---
phase: 15-encrypted-key-crypto-layer
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/crypto/mod.rs
autonomous: true
requirements:
  - KEYS-05

must_haves:
  truths:
    - "encrypt_key_envelope produces a binary blob starting with CCLINKEK magic header, version 0x01, Argon2 params, 32-byte salt, and age ciphertext"
    - "decrypt_key_envelope with the correct passphrase round-trips back to the original 32-byte seed"
    - "decrypt_key_envelope with a wrong passphrase returns a clear error containing 'passphrase' or 'envelope' (not a panic or raw age error)"
    - "Argon2 parameters are read from the envelope header on decryption, not from hardcoded constants"
    - "The HKDF info string cclink-key-v1 is distinct from cclink-pin-v1 and produces different derived keys for the same input"
  artifacts:
    - path: "src/crypto/mod.rs"
      provides: "encrypt_key_envelope, decrypt_key_envelope, key_derive_key functions"
      contains: "CCLINKEK"
  key_links:
    - from: "encrypt_key_envelope"
      to: "key_derive_key"
      via: "Argon2id + HKDF derivation with cclink-key-v1 info string"
      pattern: "key_derive_key\\(passphrase"
    - from: "decrypt_key_envelope"
      to: "key_derive_key"
      via: "Re-derives key from envelope header params (not constants)"
      pattern: "key_derive_key\\(passphrase.*m_cost.*t_cost.*p_cost"
    - from: "encrypt_key_envelope"
      to: "age_encrypt"
      via: "Encrypts seed bytes with age using derived key"
      pattern: "age_encrypt\\(seed"
    - from: "decrypt_key_envelope"
      to: "age_decrypt"
      via: "Decrypts ciphertext from envelope with age using derived key"
      pattern: "age_decrypt\\(ciphertext"
---

<objective>
Implement the CCLINKEK binary envelope encrypt/decrypt crypto layer using TDD.

Purpose: Phase 15 adds the passphrase-based key encryption functions that Phase 16 will wire into `cclink init` and key loading. The functions encrypt and decrypt an Ed25519 seed (32 bytes) into a self-describing binary envelope with embedded Argon2 parameters for forward compatibility.

Output: `encrypt_key_envelope`, `decrypt_key_envelope`, and private `key_derive_key` helper in `src/crypto/mod.rs`, with comprehensive unit tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-encrypted-key-crypto-layer/15-RESEARCH.md
@src/crypto/mod.rs
</context>

<feature>
  <name>CCLINKEK Binary Envelope Encrypt/Decrypt</name>
  <files>src/crypto/mod.rs</files>
  <behavior>
    The feature adds three functions to `src/crypto/mod.rs`:

    1. **`key_derive_key(passphrase, salt, m_cost, t_cost, p_cost) -> Zeroizing<[u8;32]>`** (private)
       - Mirrors `pin_derive_key` but uses HKDF info string `b"cclink-key-v1"` (not `b"cclink-pin-v1"`)
       - Accepts Argon2 params as arguments (not hardcoded) so decrypt can pass header-decoded values
       - All intermediates (`argon2_output`, `okm`) wrapped in `Zeroizing`

    2. **`encrypt_key_envelope(seed: &[u8;32], passphrase: &str) -> anyhow::Result<Vec<u8>>`** (public)
       - Generates random 32-byte salt
       - Uses default Argon2 params: m_cost=65536, t_cost=3, p_cost=1
       - Calls `key_derive_key` to derive key-encryption key
       - Builds `age_identity` from derived key, gets `recipient = identity.to_public()`
       - Calls `age_encrypt(seed, &recipient)` to encrypt the 32-byte seed
       - Serializes binary envelope: `CCLINKEK` (8 bytes) + version 0x01 (1 byte) + m_cost BE (4) + t_cost BE (4) + p_cost BE (4) + salt (32) + age ciphertext (variable)
       - Returns the complete envelope as `Vec<u8>`

    3. **`decrypt_key_envelope(envelope: &[u8], passphrase: &str) -> anyhow::Result<Zeroizing<[u8;32]>>`** (public)
       - Validates `envelope.len() >= 53` (HEADER_LEN)
       - Validates magic bytes `== b"CCLINKEK"`
       - Validates version byte `== 0x01`
       - Decodes m_cost, t_cost, p_cost from header bytes (NOT from constants)
       - Extracts 32-byte salt from header
       - Extracts age ciphertext as `&envelope[53..]`
       - Calls `key_derive_key(passphrase, &salt, m_cost, t_cost, p_cost)`
       - Calls `age_decrypt(ciphertext, &identity)` with `.map_err(|_| anyhow!("Wrong passphrase or corrupted key envelope"))`
       - Validates recovered plaintext is exactly 32 bytes
       - Returns `Zeroizing<[u8;32]>` (not `Vec<u8>`)

    Named constants to add:
    - `const ENVELOPE_MAGIC: &[u8; 8] = b"CCLINKEK";`
    - `const ENVELOPE_VERSION: u8 = 0x01;`
    - `const ENVELOPE_HEADER_LEN: usize = 53;`
    - `const KEY_HKDF_INFO: &[u8] = b"cclink-key-v1";`
    - `const KDF_M_COST: u32 = 65536;`
    - `const KDF_T_COST: u32 = 3;`
    - `const KDF_P_COST: u32 = 1;`

    Test cases (RED phase):
    - `test_key_envelope_round_trip`: encrypt seed [42u8;32] with passphrase, decrypt with same passphrase, assert recovered == original
    - `test_key_envelope_magic_and_version`: encrypt, assert blob[..8] == b"CCLINKEK", blob[8] == 0x01, blob.len() > 53
    - `test_key_envelope_params_stored_in_header`: encrypt, decode m_cost/t_cost/p_cost from header bytes, assert 65536/3/1
    - `test_key_envelope_wrong_passphrase`: encrypt with "correct", decrypt with "wrong", assert Err with message containing "passphrase" or "envelope"
    - `test_key_envelope_too_short`: pass 52-byte buffer to decrypt, assert Err (not panic)
    - `test_key_envelope_wrong_magic`: pass buffer with wrong magic, assert Err
    - `test_key_hkdf_info_distinct_from_pin`: derive key with key_derive_key and pin_derive_key using same passphrase+salt, assert different outputs
    - `test_key_derive_key_deterministic`: same passphrase+salt+params produces same key
  </behavior>
  <implementation>
    Follow the exact patterns from 15-RESEARCH.md. Key implementation notes:

    1. Place constants BEFORE existing `ed25519_to_x25519_secret` function (after the `use` imports, near the top of the file alongside any existing constants).

    2. Place `key_derive_key` as a private `fn` (no `pub`) after `pin_decrypt` and before the `#[cfg(test)] mod tests` block. It mirrors `pin_derive_key` exactly, except:
       - Uses `KEY_HKDF_INFO` (`b"cclink-key-v1"`) instead of `b"cclink-pin-v1"`
       - Accepts `m_cost`, `t_cost`, `p_cost` as parameters instead of hardcoding them

    3. Place `encrypt_key_envelope` and `decrypt_key_envelope` as `pub fn` after `key_derive_key`, before the tests block.

    4. In `decrypt_key_envelope`, the `.map_err(|_| ...)` on `age_decrypt` is critical -- it replaces the raw age error with "Wrong passphrase or corrupted key envelope" to satisfy success criterion 3.

    5. In `decrypt_key_envelope`, after age_decrypt returns plaintext Vec<u8>, copy into `Zeroizing<[u8;32]>` and return that. Do NOT return the raw Vec.

    6. No new crate dependencies. All imports (`argon2`, `hkdf`, `sha2`, `rand`, `zeroize`, `age`) are already in the file's `use` block or available from existing Cargo.toml deps.

    7. `cargo clippy --all-targets -- -D warnings` and `cargo fmt --check` must pass.
  </implementation>
</feature>

<verification>
```bash
# All tests pass (including new envelope tests)
cargo test --lib crypto -- --nocapture 2>&1 | tail -20

# Clippy clean
cargo clippy --all-targets -- -D warnings

# Format clean
cargo fmt --check

# Full test suite (no regressions)
cargo test
```
</verification>

<success_criteria>
1. `cargo test --lib crypto` passes all new envelope tests (round-trip, wrong passphrase, header validation, domain separation, determinism, short/wrong-magic error paths)
2. `cargo test` passes with zero failures (no regressions to existing PIN/age tests)
3. `cargo clippy --all-targets -- -D warnings` exits 0
4. `cargo fmt --check` exits 0
5. `encrypt_key_envelope` output starts with `CCLINKEK\x01` and contains Argon2 params in big-endian at known offsets
6. `decrypt_key_envelope` with correct passphrase recovers original seed
7. `decrypt_key_envelope` with wrong passphrase returns error mentioning "passphrase" or "envelope"
8. `key_derive_key` with `"cclink-key-v1"` produces different output than `pin_derive_key` with `"cclink-pin-v1"` for same inputs
</success_criteria>

<output>
After completion, create `.planning/phases/15-encrypted-key-crypto-layer/15-01-SUMMARY.md`
</output>
