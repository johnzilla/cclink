---
phase: 06-signed-record-format
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/keys/store.rs
autonomous: true
requirements:
  - SEC-02

must_haves:
  truths:
    - "Loading the secret key fails with a clear error if file permissions are not 0600"
    - "Writing a new keypair sets file permissions to 0600 explicitly after the atomic write"
    - "All cclink operations that load the key enforce permission checks (not delegated to pkarr)"
  artifacts:
    - path: "src/keys/store.rs"
      provides: "Permission enforcement on load and write"
      contains: "0o600"
    - path: "src/keys/store.rs"
      provides: "CclinkError variant or anyhow error for permission violation"
  key_links:
    - from: "src/keys/store.rs"
      to: "src/keys/store.rs"
      via: "load_keypair calls permission check before reading key file"
      pattern: "permissions.*mode"
    - from: "src/keys/store.rs"
      to: "src/keys/store.rs"
      via: "write_keypair_atomic sets 0600 after rename"
      pattern: "set_permissions"
---

<objective>
Enforce 0600 file permissions on the secret key file in cclink's own code, both when writing new keys and when loading existing keys.

Purpose: SEC-02 requires that cclink itself enforces key file permissions rather than relying on pkarr or the user. Any key file with permissions other than 0600 should be rejected on load, and any newly written key should have 0600 set explicitly.

Output: Updated `store.rs` with permission enforcement on load and write, plus unit tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/keys/store.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enforce 0600 permissions on key file load and write</name>
  <files>src/keys/store.rs</files>
  <action>
  **RED phase (write failing tests first):**

  Add the following unit tests to `src/keys/store.rs` (create a `#[cfg(test)] mod tests` block):

  1. `test_enforce_permissions_rejects_0644` (Unix only, `#[cfg(unix)]`):
     - Create a temp directory with `tempfile::tempdir()` (add `tempfile` as dev-dependency if not present: `cargo add tempfile --dev`)
     - Generate a keypair with `pkarr::Keypair::random()`
     - Write the keypair to a temp file using `keypair.write_secret_key_file(&path)`
     - Set permissions to 0o644 using `std::fs::set_permissions(&path, Permissions::from_mode(0o644))`
     - Call the new `check_key_permissions(&path)` function
     - Assert it returns an error containing "permissions"

  2. `test_enforce_permissions_accepts_0600` (Unix only, `#[cfg(unix)]`):
     - Same setup but set permissions to 0o600
     - Call `check_key_permissions(&path)`
     - Assert it returns Ok

  3. `test_write_keypair_atomic_sets_0600` (Unix only, `#[cfg(unix)]`):
     - Create a temp directory
     - Call `write_keypair_atomic()` with a new keypair
     - Read back the file permissions
     - Assert the mode is 0o600

  Run `cargo test -p cclink keys::store::tests` — tests MUST FAIL (functions don't exist yet or don't enforce permissions).

  **GREEN phase (make tests pass):**

  Add a `check_key_permissions` function to `src/keys/store.rs`:

  ```rust
  /// Check that the key file has exactly 0600 permissions (Unix only).
  ///
  /// Returns an error if the file permissions allow group or other access.
  /// This is a security check — secret key files must not be readable by
  /// other users on the system.
  #[cfg(unix)]
  pub fn check_key_permissions(path: &Path) -> anyhow::Result<()> {
      use std::os::unix::fs::PermissionsExt;
      let metadata = std::fs::metadata(path)
          .with_context(|| format!("Failed to read metadata for {}", path.display()))?;
      let mode = metadata.permissions().mode() & 0o777;
      if mode != 0o600 {
          anyhow::bail!(
              "Key file {} has insecure permissions {:04o} (expected 0600). Fix with: chmod 600 {}",
              path.display(),
              mode,
              path.display()
          );
      }
      Ok(())
  }

  /// No-op on non-Unix platforms.
  #[cfg(not(unix))]
  pub fn check_key_permissions(_path: &Path) -> anyhow::Result<()> {
      Ok(())
  }
  ```

  Update `load_keypair()` to call `check_key_permissions(&path)?;` BEFORE calling `pkarr::Keypair::from_secret_key_file(&path)`. The permission check must happen first — reject the key before even reading it if permissions are wrong.

  Update `write_keypair_atomic()` to set 0600 permissions AFTER the `std::fs::rename()` succeeds:

  ```rust
  // After successful rename:
  #[cfg(unix)]
  {
      use std::os::unix::fs::PermissionsExt;
      std::fs::set_permissions(dest, std::fs::Permissions::from_mode(0o600))
          .with_context(|| format!("Failed to set 0600 permissions on {}", dest.display()))?;
  }
  ```

  Run `cargo test -p cclink keys::store::tests` — all tests must pass.

  **REFACTOR phase:** Add doc comments to `load_keypair()` noting the permission check. Update `write_keypair_atomic()` doc comment to note 0600 enforcement. Ensure the error message in `check_key_permissions` includes the remediation command (`chmod 600`).
  </action>
  <verify>
  ```bash
  cargo test -p cclink keys::store::tests
  ```
  All store tests pass. On Unix, permission checks are enforced.

  ```bash
  cargo test
  ```
  Full test suite passes (permission changes don't break existing tests).

  ```bash
  cargo build 2>&1 | grep -i warning || echo "No warnings"
  ```
  No compiler warnings.
  </verify>
  <done>Key file permissions are enforced to 0600 on load (reject if wrong) and on write (set explicitly after atomic rename). The check includes a user-friendly error message with the fix command. Non-Unix platforms have a no-op fallback. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cargo test` — all unit and integration tests pass
2. `cargo build` — compiles without warnings
3. In `src/keys/store.rs`: `load_keypair()` calls `check_key_permissions()` before reading the key file
4. In `src/keys/store.rs`: `write_keypair_atomic()` sets 0600 permissions after successful rename
5. In `src/keys/store.rs`: `check_key_permissions()` exists with both `#[cfg(unix)]` and `#[cfg(not(unix))]` variants
6. Error message includes the remediation command (`chmod 600`)
</verification>

<success_criteria>
- Loading a key file with permissions other than 0600 produces a clear error with remediation instructions
- Writing a new keypair explicitly sets 0600 permissions on the resulting file
- Permission enforcement is in cclink's own code, not delegated to pkarr
- Non-Unix platforms compile and run without errors (no-op permission check)
- All tests pass, no compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-signed-record-format/06-02-SUMMARY.md`
</output>
