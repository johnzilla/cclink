---
phase: 06-signed-record-format
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/record/mod.rs
  - src/commands/publish.rs
  - tests/integration_round_trip.rs
autonomous: true
requirements:
  - SEC-01

must_haves:
  truths:
    - "burn and recipient fields are inside the signed envelope (HandoffRecordSignable includes them)"
    - "Tampering with burn flag on a v1.1 record causes signature verification failure"
    - "Tampering with recipient field on a v1.1 record causes signature verification failure"
    - "v1.0 records (without burn/recipient in signable) are NOT supported — clean break, they expire via TTL"
  artifacts:
    - path: "src/record/mod.rs"
      provides: "HandoffRecordSignable with burn and recipient fields"
      contains: "pub burn: bool"
    - path: "src/record/mod.rs"
      provides: "Updated From<&HandoffRecord> including burn and recipient"
      contains: "burn: record.burn"
    - path: "tests/integration_round_trip.rs"
      provides: "Integration test proving burn-tampered record fails verification"
  key_links:
    - from: "src/commands/publish.rs"
      to: "src/record/mod.rs"
      via: "HandoffRecordSignable construction includes burn and recipient fields"
      pattern: "burn.*cli\\.burn"
    - from: "src/record/mod.rs"
      to: "src/record/mod.rs"
      via: "verify_record extracts signable with burn+recipient, canonical JSON changes break old sigs"
      pattern: "HandoffRecordSignable::from"
---

<objective>
Move burn and recipient fields into the signed envelope so that tampering with either field causes signature verification failure.

Purpose: SEC-01 requires cryptographic honesty — burn intent and recipient designation must be signed, not unsigned metadata. This is a clean break from v1.0 format (no version negotiation; v1.0 records expire via TTL).

Output: Updated HandoffRecordSignable, signing/verification, publish command, and tests proving tamper detection.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/record/mod.rs
@src/commands/publish.rs
@tests/integration_round_trip.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add burn and recipient to HandoffRecordSignable and update signing</name>
  <files>src/record/mod.rs</files>
  <action>
  **RED phase (write failing tests first):**

  Add three new unit tests to `src/record/mod.rs`:
  1. `test_signable_includes_burn_field` — create a HandoffRecordSignable with `burn: true`, serialize to canonical JSON, assert `"burn":true` appears in the JSON output.
  2. `test_signable_includes_recipient_field` — create a HandoffRecordSignable with `recipient: Some("abc123".to_string())`, serialize to canonical JSON, assert `"recipient":"abc123"` appears in the JSON output.
  3. `test_tampered_burn_fails_verification` — sign a record with `burn: false`, then construct a HandoffRecord from the same signable but with `burn: true` (tampered), call `verify_record()` and assert it fails.

  Run `cargo test -p cclink record::tests` — all three new tests MUST FAIL (fields don't exist on HandoffRecordSignable yet).

  **GREEN phase (make tests pass):**

  Modify `HandoffRecordSignable` to include:
  - `pub burn: bool` — insert alphabetically after `blob` field
  - `pub recipient: Option<String>` — insert alphabetically after `pubkey` field

  CRITICAL alphabetical ordering (serde serializes in declaration order):
  ```
  blob, burn, created_at, hostname, project, pubkey, recipient, signature, ttl
  ```
  But HandoffRecordSignable excludes `signature`, so:
  ```
  blob, burn, created_at, hostname, project, pubkey, recipient, ttl
  ```

  Update `From<&HandoffRecord> for HandoffRecordSignable` to copy burn and recipient:
  ```rust
  burn: record.burn,
  recipient: record.recipient.clone(),
  ```

  Update `sample_signable()` helper to include `burn: false` and `recipient: None`.

  Update `test_sign_and_verify_round_trip` to construct HandoffRecordSignable with the new fields.

  Update `test_handoff_record_signable_serializes_alphabetical_keys` to assert `burn` and `recipient` positions.

  Remove `test_phase3_record_backwards_compat` entirely — v1.1 is a clean break, v1.0 records expire via TTL per STATE.md decision. This test is now incorrect since signable fields have changed.

  Run `cargo test -p cclink record::tests` — ALL tests must pass.

  **REFACTOR phase:** Ensure all doc comments on HandoffRecordSignable are updated to reflect that burn and recipient are NOW included in the signed envelope. Remove all references to "unsigned metadata" from both HandoffRecord and HandoffRecordSignable doc comments. Update HandoffRecord doc comments to note that burn and recipient are signed as of v1.1.
  </action>
  <verify>
  ```bash
  cargo test -p cclink record::tests
  ```
  All record module tests pass. The three new tests (signable_includes_burn, signable_includes_recipient, tampered_burn_fails_verification) all pass.
  </verify>
  <done>HandoffRecordSignable includes burn and recipient in the signed envelope. Tampering with either field after signing causes verify_record to fail. Canonical JSON key ordering is correct (alphabetical). No backwards compatibility with v1.0 unsigned format (clean break).</done>
</task>

<task type="auto">
  <name>Task 2: Update publish command and integration tests for signed burn/recipient</name>
  <files>src/commands/publish.rs, tests/integration_round_trip.rs</files>
  <action>
  Update `src/commands/publish.rs` section 5 ("Build and sign record") to include burn and recipient in the HandoffRecordSignable construction:

  Change the signable construction from:
  ```rust
  let signable = crate::record::HandoffRecordSignable {
      blob,
      created_at,
      hostname,
      project: session.project.clone(),
      pubkey: keypair.public_key().to_z32(),
      ttl: cli.ttl,
  };
  ```
  To:
  ```rust
  let signable = crate::record::HandoffRecordSignable {
      blob,
      burn: cli.burn,
      created_at,
      hostname,
      project: session.project.clone(),
      pubkey: keypair.public_key().to_z32(),
      recipient: cli.share.clone(),
      ttl: cli.ttl,
  };
  ```

  Note: fields MUST remain in alphabetical order in the struct literal to match the struct declaration.

  Update `tests/integration_round_trip.rs` to add a new test:

  `test_signed_burn_tamper_detection` — build a full signed HandoffRecord with burn=false, verify it passes. Then clone the record, set burn=true (tamper), call `cclink::record::verify_record()`, assert it fails. This tests the full integration path (not just unit-level).

  Also add `test_signed_recipient_tamper_detection` — same approach: sign with recipient=None, tamper to Some("attacker"), verify fails.

  Update existing integration tests to ensure HandoffRecordSignable construction (if any test constructs one) includes the new burn and recipient fields.

  Run full test suite:
  ```bash
  cargo test
  ```
  </action>
  <verify>
  ```bash
  cargo test
  ```
  Full test suite passes with zero failures. The two new integration tests (signed_burn_tamper_detection, signed_recipient_tamper_detection) pass. No compiler warnings related to the record module changes.
  </verify>
  <done>Publish command signs burn and recipient into the payload. Integration tests prove that tampering with burn or recipient on a v1.1 record causes signature verification failure. The full sign-verify pipeline is tested end-to-end.</done>
</task>

</tasks>

<verification>
1. `cargo test` — all unit and integration tests pass
2. `cargo build` — compiles without warnings related to record/publish changes
3. In `src/record/mod.rs`: HandoffRecordSignable struct contains `burn: bool` and `recipient: Option<String>` fields
4. In `src/record/mod.rs`: no references to "unsigned metadata" remain in doc comments for burn/recipient
5. In `src/commands/publish.rs`: HandoffRecordSignable construction includes `burn: cli.burn` and `recipient: cli.share.clone()`
6. `test_phase3_record_backwards_compat` test is removed (clean break)
</verification>

<success_criteria>
- HandoffRecordSignable includes burn and recipient in the signed envelope
- Tampering with burn flag after signing causes verification failure (proven by test)
- Tampering with recipient field after signing causes verification failure (proven by test)
- Publish command correctly populates burn and recipient in the signable struct
- All tests pass, no compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/06-signed-record-format/06-01-SUMMARY.md`
</output>
