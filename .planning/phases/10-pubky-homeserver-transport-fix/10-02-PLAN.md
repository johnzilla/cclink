---
phase: 10-pubky-homeserver-transport-fix
plan: 02
type: execute
wave: 2
depends_on:
  - "10-01"
files_modified:
  - src/commands/publish.rs
  - src/commands/pickup.rs
  - src/commands/list.rs
  - src/commands/revoke.rs
  - src/transport/mod.rs
  - tests/integration_round_trip.rs
autonomous: true
requirements:
  - FUNC-04

must_haves:
  truths:
    - "All command modules pass the keypair's z32 pubkey when constructing HomeserverClient"
    - "Cross-user pickup passes the target user's z32 pubkey for Host header routing"
    - "List parsing correctly handles full pubky:// URI format from homeserver directory listings"
    - "Full end-to-end flow compiles and unit tests pass: cclink init -> publish -> pickup"
  artifacts:
    - path: "src/commands/publish.rs"
      provides: "Updated HomeserverClient construction with pubkey_z32"
      contains: "HomeserverClient::new"
    - path: "src/commands/pickup.rs"
      provides: "Updated HomeserverClient construction and cross-user Host header routing"
      contains: "HomeserverClient::new"
    - path: "src/commands/list.rs"
      provides: "Updated HomeserverClient construction with pubkey_z32"
      contains: "HomeserverClient::new"
    - path: "src/commands/revoke.rs"
      provides: "Updated HomeserverClient construction with pubkey_z32"
      contains: "HomeserverClient::new"
    - path: "src/transport/mod.rs"
      provides: "Robust list_record_tokens parsing for pubky:// URIs"
      contains: "pubky://"
  key_links:
    - from: "src/commands/publish.rs"
      to: "HomeserverClient::new"
      via: "keypair.public_key().to_z32()"
      pattern: "to_z32\\(\\)"
    - from: "src/commands/pickup.rs"
      to: "HomeserverClient::new"
      via: "keypair.public_key().to_z32()"
      pattern: "to_z32\\(\\)"
    - from: "list_record_tokens"
      to: "pubky:// URI parsing"
      via: "split on /pub/cclink/"
      pattern: "/pub/cclink/"
---

<objective>
Update all command modules to pass pubkey_z32 to the new HomeserverClient constructor, fix cross-user pickup Host header routing, and harden list parsing for pubky:// URI format.

Purpose: Plan 01 changed HomeserverClient::new() to require a pubkey_z32 parameter. All callers must be updated. Additionally, the pickup command needs to construct a second client (or reconfigure the Host header) for cross-user operations, and list parsing must handle the full pubky:// URI format returned by the homeserver.

Output: All command modules compile and work with the updated transport API. List parsing handles both legacy and pubky:// URI formats. Full test suite passes.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-pubky-homeserver-transport-fix/10-01-SUMMARY.md
@src/transport/mod.rs
@src/commands/publish.rs
@src/commands/pickup.rs
@src/commands/list.rs
@src/commands/revoke.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update command modules to pass pubkey_z32 to HomeserverClient::new</name>
  <files>
    src/commands/publish.rs
    src/commands/pickup.rs
    src/commands/list.rs
    src/commands/revoke.rs
  </files>
  <action>
  Update every call site of `HomeserverClient::new()` to pass the keypair's z32 pubkey:

  1. **publish.rs** (line ~143):
     Change:
     ```rust
     let client = crate::transport::HomeserverClient::new(&homeserver)?;
     ```
     To:
     ```rust
     let pubkey_z32 = keypair.public_key().to_z32();
     let client = crate::transport::HomeserverClient::new(&homeserver, &pubkey_z32)?;
     ```
     Note: `pubkey_z32` is already computed on line ~124 for the signable struct. Reuse that value or compute once before the client construction line. The simplest approach is to compute it once early and reuse it for both the record and the client.

  2. **list.rs** (line ~17):
     Change:
     ```rust
     let client = crate::transport::HomeserverClient::new(&homeserver)?;
     ```
     To:
     ```rust
     let pubkey_z32 = keypair.public_key().to_z32();
     let client = crate::transport::HomeserverClient::new(&homeserver, &pubkey_z32)?;
     ```

  3. **revoke.rs** (line ~20):
     Change:
     ```rust
     let client = crate::transport::HomeserverClient::new(&homeserver)?;
     ```
     To:
     ```rust
     let pubkey_z32 = keypair.public_key().to_z32();
     let client = crate::transport::HomeserverClient::new(&homeserver, &pubkey_z32)?;
     ```

  4. **pickup.rs** (line ~51): This is the most complex update because pickup handles both self and cross-user operations.

     For self-pickup: the Host header should be the user's own z32 pubkey.
     For cross-user pickup: the Host header should be the TARGET user's z32 pubkey (the publisher's pubkey).

     Update the client construction:
     ```rust
     let own_z32 = keypair.public_key().to_z32();
     ```

     For the cross-user path: When `args.pubkey` is `Some(ref pk_z32)`, the client needs to send requests with the TARGET user's pubkey in the Host header. The simplest approach is:
     - Construct the client with the appropriate pubkey for the operation:
       - For cross-user: use `pk_z32` as the pubkey_z32 (since we're reading from their namespace)
       - For self: use `own_z32`

     Change:
     ```rust
     let client = crate::transport::HomeserverClient::new(&homeserver)?;
     ```
     To:
     ```rust
     let own_z32 = keypair.public_key().to_z32();
     let host_z32 = match &args.pubkey {
         Some(pk) => pk.as_str(),
         None => own_z32.as_str(),
     };
     let client = crate::transport::HomeserverClient::new(&homeserver, host_z32)?;
     ```

     This works because:
     - Self-pickup: all operations (signin, get_latest, get_record) use own pubkey as Host
     - Cross-user pickup: get_latest and get_record use the publisher's pubkey as Host (correct — reading from their namespace). The client does NOT call signin for cross-user (signin is only called in the self-pickup branch inside the retry loop).

     **IMPORTANT**: In the cross-user branch inside the retry loop, `client.get_record_by_pubkey()` is called. After Plan 01's changes, this method already uses the Host header from the constructor. But we need to verify: `get_record_by_pubkey` was updated to use Host header routing instead of path-based. The `pubkey_z32` parameter to `get_record_by_pubkey` is now used for the Host header (passed through to `get_bytes`). Since the client is already constructed with the target pubkey, we should simplify the cross-user path to just use `get_record()` instead of `get_record_by_pubkey()`, since the Host header already routes to the correct tenant.

     Actually, keep `get_record_by_pubkey()` as the API for cross-user reads — it clearly communicates intent and passes the target pubkey explicitly to the Host header. The client's default pubkey_z32 is used for self-operations only.

     In the cross-user branch, the call to `client.get_latest(Some(pk_z32))` uses the pk_z32 for the Host header via the `get_latest` method. After Plan 01, `get_latest(Some(pk))` passes `Some(pk)` to `get_bytes` which sets the Host header to pk. This is correct.

     For the self-pickup branch, `client.signin(&keypair)` uses `self.pubkey_z32` (which is `host_z32` = `own_z32`). Then `client.get_record(token, ...)` uses `self.pubkey_z32` for the Host header. Correct.

     The only subtle issue: in the self-pickup branch, `client.get_latest(None)` passes `None`, which means `get_bytes` uses `self.pubkey_z32` = `own_z32`. Correct.

     In the cross-user branch, `client.get_latest(Some(pk_z32))` should override the Host header. After Plan 01, this is handled by the `host_pubkey` parameter to `get_bytes`. BUT wait — the client was constructed with `host_z32 = pk_z32` for cross-user. So `get_latest(None)` would also work (since the default is already the target). However, for clarity, keep passing `Some(pk_z32)` explicitly.

     Net change for pickup.rs:
     - Add `let own_z32 = keypair.public_key().to_z32();`
     - Compute `host_z32` based on `args.pubkey`
     - Pass `host_z32` to `HomeserverClient::new`
     - No other changes needed to the retry loop logic
  </action>
  <verify>
  Run `cargo build` — must compile with zero errors.
  Grep all command files for `HomeserverClient::new` and verify each call passes two arguments.
  </verify>
  <done>
  All four command modules pass a z32 pubkey to HomeserverClient::new. Cross-user pickup uses the target user's pubkey for Host header routing. Self-operations use the owner's pubkey.
  </done>
</task>

<task type="auto">
  <name>Task 2: Harden list_record_tokens parsing and add unit tests for pubky:// URI format</name>
  <files>
    src/transport/mod.rs
  </files>
  <action>
  The homeserver directory listing returns full `pubky://<pubkey>/pub/cclink/token` URIs as newline-separated text. The current parsing in `list_record_tokens()` splits on `"/pub/cclink/"` and takes the second part. This should work, but needs hardening and test coverage.

  1. **Verify and harden the parsing logic** in `list_record_tokens()`:
     Current code:
     ```rust
     .filter_map(|line| {
         line.split("/pub/cclink/").nth(1)
             .map(|t| t.trim_end_matches('/').to_string())
     })
     ```
     This correctly handles:
     - `pubky://abc123xyz.../pub/cclink/1700000000` → `1700000000`
     - `/pub/cclink/1700000000` → `1700000000` (legacy format)
     - `pubky://abc123xyz.../pub/cclink/latest` → `latest` (filtered by next step)

     The logic is correct. Add a comment documenting the expected input format:
     ```rust
     // Homeserver returns full pubky:// URIs, e.g.:
     //   pubky://<z32-pubkey>/pub/cclink/1700000000
     //   pubky://<z32-pubkey>/pub/cclink/latest
     // Split on "/pub/cclink/" to extract the token portion.
     ```

  2. **Add unit tests** for the parsing logic. Since `list_record_tokens` makes an HTTP call, extract the parsing into a testable helper or test the parsing inline. The simplest approach: add a `#[cfg(test)]` helper function that mirrors the parsing logic, and test it with various input formats:

     ```rust
     #[cfg(test)]
     fn parse_record_tokens(body: &str) -> Vec<String> {
         body.lines()
             .filter(|l| !l.is_empty())
             .filter_map(|line| {
                 line.split("/pub/cclink/").nth(1)
                     .map(|t| t.trim_end_matches('/').to_string())
             })
             .filter(|t| t.parse::<u64>().is_ok())
             .collect()
     }
     ```

     Test cases:
     - Full pubky:// URIs: `"pubky://abc123/pub/cclink/1700000000\npubky://abc123/pub/cclink/latest\n"` → `["1700000000"]`
     - Plain paths: `"/pub/cclink/1700000000\n/pub/cclink/latest\n"` → `["1700000000"]`
     - Mixed: `"pubky://abc123/pub/cclink/1700000000\n/pub/cclink/1700000001\n"` → `["1700000000", "1700000001"]`
     - Empty body: `""` → `[]`
     - Only "latest": `"pubky://abc123/pub/cclink/latest\n"` → `[]`
     - Trailing slashes: `"pubky://abc123/pub/cclink/1700000000/\n"` → `["1700000000"]`

  3. **Also add Host header** to the `list_record_tokens()` GET request if not already done in Plan 01. The request at `https://{homeserver}/pub/cclink/` must include `.header("Host", &self.pubkey_z32)`. Verify this was done in Plan 01; if missed, add it here.
  </action>
  <verify>
  Run `cargo test --lib transport::tests` — all tests pass, including the new parsing tests.
  Run `cargo build` — zero errors, zero warnings.
  </verify>
  <done>
  List parsing is documented and tested for both pubky:// URI format and plain path format. Unit tests cover edge cases (empty body, "latest" filtering, trailing slashes, mixed formats).
  </done>
</task>

<task type="auto">
  <name>Task 3: Update existing tests and run full test suite</name>
  <files>
    tests/integration_round_trip.rs
    src/transport/mod.rs
  </files>
  <action>
  Ensure the full test suite (unit + integration) compiles and passes with the transport changes:

  1. **Check `tests/integration_round_trip.rs`** — this file uses `cclink::transport` and `cclink::record` but does NOT construct `HomeserverClient` directly (it tests crypto round-trips). Verify it still compiles. It should not need changes since it doesn't call `HomeserverClient::new()`.

  2. **Check `tests/plaintext_leak.rs`** — same verification. Should not use `HomeserverClient`.

  3. **Run the full test suite**:
     ```bash
     cargo test
     ```
     All non-ignored tests must pass.

  4. **Run clippy** for code quality:
     ```bash
     cargo clippy -- -D warnings
     ```
     Must produce zero warnings.

  5. **Verify zero compiler warnings**:
     ```bash
     cargo build 2>&1
     ```
     Must show zero warnings.

  6. If any test or clippy issue is found, fix it. Common issues:
     - Unused variables from the refactored `get_record_by_pubkey` (pubkey_z32 no longer used in URL, only in Host header)
     - Dead code from removed URL path logic
     - Test assertions that reference the old URL format
  </action>
  <verify>
  `cargo test` — all non-ignored tests pass (exit code 0).
  `cargo clippy -- -D warnings` — zero warnings.
  `cargo build` — zero warnings.
  </verify>
  <done>
  Full test suite passes. Clippy clean. Zero compiler warnings. The transport layer is ready for live verification against pubky.app.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` — zero errors, zero warnings
2. `cargo test` — all non-ignored tests pass
3. `cargo clippy -- -D warnings` — zero warnings
4. All `HomeserverClient::new()` calls in command modules pass two arguments (homeserver + pubkey_z32)
5. Cross-user pickup in pickup.rs uses the target pubkey for Host header routing
6. `list_record_tokens` parsing handles `pubky://` URI format (tested)
7. No remaining path-based pubkey embedding in URLs (grep for `/{pubkey` or similar patterns returns nothing)
</verification>

<success_criteria>
All command modules compile and work with the updated transport API. List parsing correctly handles pubky:// URI format. Full test suite (cargo test + clippy) passes. The codebase is ready for end-to-end live testing against pubky.app.
</success_criteria>

<output>
After completion, create `.planning/phases/10-pubky-homeserver-transport-fix/10-02-SUMMARY.md`
</output>
