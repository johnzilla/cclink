---
phase: 07-code-quality-and-transport
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/transport/mod.rs
  - src/commands/list.rs
  - .planning/ROADMAP.md
autonomous: true
requirements:
  - QUAL-04
  - FUNC-03

must_haves:
  truths:
    - "HomeserverClient signs in once per process and reuses the session cookie for all subsequent operations"
    - "`cclink list` makes one transport-layer call (`get_all_records`), not N individual `get_record` calls from the command layer — individual HTTP fetches are encapsulated inside the transport layer because the Pubky homeserver has no batch-get endpoint"
    - "Commands that call multiple authenticated methods (publish: signin+PUT+PUT, list: signin+list+get, revoke: signin+list+delete) only trigger one actual signin HTTP call"
  artifacts:
    - path: "src/transport/mod.rs"
      provides: "HomeserverClient with lazy signin and batch get_records method"
      contains: "ensure_signed_in"
    - path: "src/commands/list.rs"
      provides: "List command using batch record fetch"
  key_links:
    - from: "src/transport/mod.rs"
      to: "src/transport/mod.rs"
      via: "ensure_signed_in called before authenticated operations"
      pattern: "ensure_signed_in"
    - from: "src/commands/list.rs"
      to: "src/transport/mod.rs"
      via: "batch record fetch replaces N individual get_record calls"
      pattern: "get_records_batch\\|get_all_records"
---

<objective>
Make HomeserverClient sign in lazily (once per process, reusing the session cookie) and encapsulate the list command's fetch-all pattern inside the transport layer.

Purpose: Each `cclink` invocation currently calls `signin()` at least once per command, and `publish()` calls it redundantly even when the caller already signed in. The list command currently loops over individual `get_record()` calls directly in command code. Lazy signin ensures one signin per process regardless of how many authenticated operations follow. Encapsulating the list+fetch pattern in `get_all_records()` moves the N individual HTTP fetches (unavoidable — the Pubky homeserver has no batch-get endpoint) into the transport layer where they belong, so the command layer makes one call.

Output: Efficient, session-reusing transport layer; list command that delegates record fetching to a single transport method; ROADMAP updated to reflect accurate success criteria.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-code-quality-and-transport/07-01-SUMMARY.md

@src/transport/mod.rs
@src/commands/list.rs
@src/commands/publish.rs
@src/commands/revoke.rs
@src/commands/pickup.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lazy signin to HomeserverClient and batch record fetching</name>
  <files>src/transport/mod.rs</files>
  <action>
1. Add `use std::cell::Cell;` to transport/mod.rs imports.

2. Add a `signed_in: Cell<bool>` field to `HomeserverClient`:
   ```rust
   pub struct HomeserverClient {
       client: reqwest::blocking::Client,
       homeserver: String,
       signed_in: Cell<bool>,
   }
   ```
   Initialize `signed_in: Cell::new(false)` in `HomeserverClient::new()`.

3. Add a private `ensure_signed_in(&self, keypair: &pkarr::Keypair) -> anyhow::Result<()>` method:
   ```rust
   fn ensure_signed_in(&self, keypair: &pkarr::Keypair) -> anyhow::Result<()> {
       if !self.signed_in.get() {
           self.signin(keypair)?;
           self.signed_in.set(true);
       }
       Ok(())
   }
   ```

4. Update `publish()` to call `self.ensure_signed_in(keypair)?` instead of `self.signin(keypair)?`. This means publish no longer forces a fresh signin — it reuses an existing session if one was established by a prior call.

5. Keep the public `signin()` method as-is (it still does the actual POST /session). Update it to also set `self.signed_in.set(true)` after success so that callers who explicitly call `signin()` (like run_list, run_revoke, run_pickup) also benefit from the guard.

6. Add a `pub fn get_all_records(&self, pubkey: &pkarr::PublicKey) -> anyhow::Result<Vec<(String, HandoffRecord)>>` method that:
   a. Calls `self.list_record_tokens()?` to get all token strings.
   b. If tokens is empty, return `Ok(vec![])`.
   c. For each token, call `self.get_record(token, pubkey)`. On success, push `(token, record)` to the result vec. On error (including CclinkError::RecordNotFound from 07-01), skip silently (matches current list.rs behavior of skipping failed records).
   d. Return the collected vec.

   NOTE: The Pubky homeserver has no native batch-get endpoint — its directory listing (`GET /pub/cclink/`) returns only path names, not record content. True single-request batching is not possible with the current protocol. The optimization here is architectural: `get_all_records()` encapsulates the 1 listing + N fetch pattern inside the transport layer, so the command layer makes ONE method call. The individual HTTP fetches are an implementation detail of transport. If the homeserver later supports batch GET, only transport/mod.rs changes.

7. Update existing transport tests to verify `signed_in` state:
   - Add a test `test_ensure_signed_in_flag` that creates a client, asserts `signed_in.get() == false`, and verifies the Cell is accessible.
  </action>
  <verify>
`cargo build 2>&1 | grep -c warning` outputs 0. `cargo test -- transport::tests` passes. `grep -n 'ensure_signed_in' src/transport/mod.rs` shows the method exists.
  </verify>
  <done>
HomeserverClient has `ensure_signed_in()` that gates on `Cell<bool>` — signin HTTP call happens at most once per client lifetime. `get_all_records()` encapsulates the list+fetch-all pattern. `publish()` uses `ensure_signed_in()` instead of raw `signin()`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update list command to use batch fetch and lazy signin</name>
  <files>src/commands/list.rs, src/commands/revoke.rs, src/commands/pickup.rs, src/commands/publish.rs</files>
  <action>
1. In `src/commands/list.rs`, replace the entire "sign in and list tokens" + "fetch each record" sections with a single call to the new transport method:
   - Remove the explicit `client.signin(&keypair)?` call.
   - Remove the `for token in &tokens { client.get_record(...) }` loop.
   - Replace with:
     ```rust
     // Sign in (lazy — will only POST /session once per client)
     client.signin(&keypair)?;

     // Fetch all records in one transport call
     let all_records = client.get_all_records(&keypair.public_key())?;
     ```
   - Filter expired records from `all_records` (same logic as before: `now_secs < created_at + ttl`).
   - Build the comfy-table from the filtered list.
   - The token is now the first element of each tuple: `for (token, record) in &active_records { ... }`.

2. In `src/commands/revoke.rs`, `src/commands/pickup.rs`, and `src/commands/publish.rs`:
   - No changes needed to the explicit `signin()` calls. These commands already call `client.signin()` once at the top. Thanks to the `signed_in` flag set in step 1 of Task 1 (the `signin()` method now sets the flag), any subsequent authenticated operations (like `publish()` calling `ensure_signed_in()`) will skip the redundant signin.
   - Verify: `publish.rs` calls `client.publish(...)` which internally called `self.signin()`. After Task 1, it now calls `self.ensure_signed_in()`. Since publish.rs doesn't call signin before publish, the ensure_signed_in will do the actual signin. This is correct — publish has one signin regardless.
   - Verify: `pickup.rs` self-pickup path calls `client.signin(&keypair)` inside the retry loop. This means each retry attempt calls signin. This is actually correct for retries (session may have expired between retries). Leave as-is — the `signed_in` Cell will be set true after first successful signin, and subsequent retries will skip it, which is the desired optimization.

3. Verify the full command flow for each command:
   - `cclink` (publish): HomeserverClient::new() -> publish() -> ensure_signed_in() -> signin once -> PUT record -> PUT latest. Total signins: 1.
   - `cclink list`: HomeserverClient::new() -> signin() -> get_all_records() [list_record_tokens + N get_record]. The list command itself makes ONE call to `get_all_records()`. Total signins: 1.
   - `cclink revoke`: HomeserverClient::new() -> signin() -> list/delete. Total signins: 1.
   - `cclink pickup`: HomeserverClient::new() -> (in retry) signin() -> get_latest -> get_record. Total signins: 1 (Cell guards subsequent calls).

4. Update `.planning/ROADMAP.md` Phase 7 success criterion #3 — replace:
   `3. \`cclink list\` with N records makes one batch HTTP request, not N individual fetches`
   With:
   `3. \`cclink list\` makes one transport-layer call (\`get_all_records\`) — individual HTTP fetches are encapsulated in the transport layer (Pubky homeserver has no batch-get endpoint)`
   This makes the success criterion match what is actually deliverable given the homeserver protocol.
  </action>
  <verify>
`cargo build 2>&1 | grep -c warning` outputs 0. `cargo test` passes all tests. `grep -n 'get_all_records' src/commands/list.rs` shows usage. `grep -c 'get_record' src/commands/list.rs` is 0 (no individual get_record calls in list command).
  </verify>
  <done>
List command calls `get_all_records()` once instead of N individual `get_record()` calls. HomeserverClient signs in once per process. All commands use one signin per invocation regardless of how many authenticated operations follow.
  </done>
</task>

</tasks>

<verification>
1. `cargo build 2>&1 | grep warning` — must produce no output (zero warnings)
2. `cargo test` — all tests pass
3. `grep -n 'ensure_signed_in' src/transport/mod.rs` — method exists and is called from publish()
4. `grep -n 'signed_in' src/transport/mod.rs` — Cell field exists in HomeserverClient struct
5. `grep -n 'get_all_records' src/commands/list.rs` — list command uses batch method
6. `grep -c 'for.*token.*in.*tokens\|get_record.*token' src/commands/list.rs` — zero matches (no per-record loop in list command)
</verification>

<success_criteria>
- HomeserverClient has a `signed_in: Cell<bool>` field and `ensure_signed_in()` method
- `publish()` uses `ensure_signed_in()` instead of `signin()` — no redundant signin
- `get_all_records()` encapsulates list+fetch pattern in the transport layer
- `run_list()` calls `get_all_records()` once instead of looping over individual `get_record()` calls
- All existing tests pass
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-code-quality-and-transport/07-02-SUMMARY.md`
</output>
