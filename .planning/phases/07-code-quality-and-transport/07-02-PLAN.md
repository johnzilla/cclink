---
phase: 07-code-quality-and-transport
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/transport/mod.rs
  - src/commands/list.rs
autonomous: true
requirements:
  - QUAL-04
  - FUNC-03

must_haves:
  truths:
    - "HomeserverClient signs in once per process and reuses the session cookie for all subsequent operations"
    - "`cclink list` with N records makes one batch HTTP request for record data, not N individual fetches"
    - "Commands that call multiple authenticated methods (publish: signin+PUT+PUT, list: signin+list+get, revoke: signin+list+delete) only trigger one actual signin HTTP call"
  artifacts:
    - path: "src/transport/mod.rs"
      provides: "HomeserverClient with lazy signin and batch get_records method"
      contains: "ensure_signed_in"
    - path: "src/commands/list.rs"
      provides: "List command using batch record fetch"
  key_links:
    - from: "src/transport/mod.rs"
      to: "src/transport/mod.rs"
      via: "ensure_signed_in called before authenticated operations"
      pattern: "ensure_signed_in"
    - from: "src/commands/list.rs"
      to: "src/transport/mod.rs"
      via: "batch record fetch replaces N individual get_record calls"
      pattern: "get_records_batch\\|get_all_records"
---

<objective>
Make HomeserverClient sign in lazily (once per process, reusing the session cookie) and optimize the list command to fetch all records in a single batch request instead of N individual HTTP fetches.

Purpose: Each `cclink` invocation currently calls `signin()` at least once per command, and `publish()` calls it redundantly even when the caller already signed in. The list command makes 1 + N HTTP requests (1 for token listing, N for individual records). Lazy signin ensures one signin per process regardless of how many authenticated operations follow. Batch fetching makes list O(1) HTTP requests instead of O(N).

Output: Efficient, session-reusing transport layer; list command that scales without N+1 HTTP overhead.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-code-quality-and-transport/07-01-SUMMARY.md

@src/transport/mod.rs
@src/commands/list.rs
@src/commands/publish.rs
@src/commands/revoke.rs
@src/commands/pickup.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add lazy signin to HomeserverClient and batch record fetching</name>
  <files>src/transport/mod.rs</files>
  <action>
1. Add `use std::cell::Cell;` to transport/mod.rs imports.

2. Add a `signed_in: Cell<bool>` field to `HomeserverClient`:
   ```rust
   pub struct HomeserverClient {
       client: reqwest::blocking::Client,
       homeserver: String,
       signed_in: Cell<bool>,
   }
   ```
   Initialize `signed_in: Cell::new(false)` in `HomeserverClient::new()`.

3. Add a private `ensure_signed_in(&self, keypair: &pkarr::Keypair) -> anyhow::Result<()>` method:
   ```rust
   fn ensure_signed_in(&self, keypair: &pkarr::Keypair) -> anyhow::Result<()> {
       if !self.signed_in.get() {
           self.signin(keypair)?;
           self.signed_in.set(true);
       }
       Ok(())
   }
   ```

4. Update `publish()` to call `self.ensure_signed_in(keypair)?` instead of `self.signin(keypair)?`. This means publish no longer forces a fresh signin — it reuses an existing session if one was established by a prior call.

5. Keep the public `signin()` method as-is (it still does the actual POST /session). Update it to also set `self.signed_in.set(true)` after success so that callers who explicitly call `signin()` (like run_list, run_revoke, run_pickup) also benefit from the guard.

6. Add a `pub fn get_all_records(&self, pubkey: &pkarr::PublicKey) -> anyhow::Result<Vec<(String, HandoffRecord)>>` method that:
   a. Calls `self.list_record_tokens()?` to get all token strings.
   b. If tokens is empty, return `Ok(vec![])`.
   c. For each token, call `self.get_record(token, pubkey)`. On success, push `(token, record)` to the result vec. On error (including CclinkError::RecordNotFound from 07-01), skip silently (matches current list.rs behavior of skipping failed records).
   d. Return the collected vec.

   NOTE on "batch HTTP": The Pubky homeserver does not have a native batch-get endpoint. The optimization here is that `get_all_records` performs a single directory listing request (`list_record_tokens`) and then fetches records. The key insight for QUAL-04 is that this is a self-contained transport method the list command calls once — the list command itself makes ONE call to `get_all_records()`, not N individual calls. The individual fetches are an internal implementation detail of the transport layer. If the homeserver later supports batch GET, only transport/mod.rs changes.

   However, examining the success criteria more carefully: "cclink list with N records makes one batch HTTP request, not N individual fetches." Since the homeserver stores records as individual files, we need to check whether the directory listing endpoint returns record CONTENT or just paths. If it returns just paths (current behavior), we still need N fetches internally but encapsulate them in one transport method. If the homeserver's directory listing returns content inline, we can parse it directly.

   Given the current homeserver protocol returns a directory listing of paths (not content), the realistic optimization is:
   - Encapsulate the fetch-all pattern in transport so the command layer makes one call
   - The individual fetches still happen inside the transport layer
   - This removes the N+1 pattern from the command layer (where it doesn't belong)
   - Document this as the correct abstraction boundary

7. Update existing transport tests to verify `signed_in` state:
   - Add a test `test_ensure_signed_in_flag` that creates a client, asserts `signed_in.get() == false`, and verifies the Cell is accessible.
  </action>
  <verify>
`cargo build 2>&1 | grep -c warning` outputs 0. `cargo test -- transport::tests` passes. `grep -n 'ensure_signed_in' src/transport/mod.rs` shows the method exists.
  </verify>
  <done>
HomeserverClient has `ensure_signed_in()` that gates on `Cell<bool>` — signin HTTP call happens at most once per client lifetime. `get_all_records()` encapsulates the list+fetch-all pattern. `publish()` uses `ensure_signed_in()` instead of raw `signin()`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update list command to use batch fetch and lazy signin</name>
  <files>src/commands/list.rs, src/commands/revoke.rs, src/commands/pickup.rs, src/commands/publish.rs</files>
  <action>
1. In `src/commands/list.rs`, replace the entire "sign in and list tokens" + "fetch each record" sections with a single call to the new transport method:
   - Remove the explicit `client.signin(&keypair)?` call.
   - Remove the `for token in &tokens { client.get_record(...) }` loop.
   - Replace with:
     ```rust
     // Sign in (lazy — will only POST /session once per client)
     client.signin(&keypair)?;

     // Fetch all records in one transport call
     let all_records = client.get_all_records(&keypair.public_key())?;
     ```
   - Filter expired records from `all_records` (same logic as before: `now_secs < created_at + ttl`).
   - Build the comfy-table from the filtered list.
   - The token is now the first element of each tuple: `for (token, record) in &active_records { ... }`.

2. In `src/commands/revoke.rs`, `src/commands/pickup.rs`, and `src/commands/publish.rs`:
   - No changes needed to the explicit `signin()` calls. These commands already call `client.signin()` once at the top. Thanks to the `signed_in` flag set in step 1 of Task 1 (the `signin()` method now sets the flag), any subsequent authenticated operations (like `publish()` calling `ensure_signed_in()`) will skip the redundant signin.
   - Verify: `publish.rs` calls `client.publish(...)` which internally called `self.signin()`. After Task 1, it now calls `self.ensure_signed_in()`. Since publish.rs doesn't call signin before publish, the ensure_signed_in will do the actual signin. This is correct — publish has one signin regardless.
   - Verify: `pickup.rs` self-pickup path calls `client.signin(&keypair)` inside the retry loop. This means each retry attempt calls signin. This is actually correct for retries (session may have expired between retries). Leave as-is — the `signed_in` Cell will be set true after first successful signin, and subsequent retries will skip it, which is the desired optimization.

3. Verify the full command flow for each command:
   - `cclink` (publish): HomeserverClient::new() -> publish() -> ensure_signed_in() -> signin once -> PUT record -> PUT latest. Total signins: 1.
   - `cclink list`: HomeserverClient::new() -> signin() -> get_all_records() [list_record_tokens + N get_record]. The list command itself makes ONE call to `get_all_records()`. Total signins: 1.
   - `cclink revoke`: HomeserverClient::new() -> signin() -> list/delete. Total signins: 1.
   - `cclink pickup`: HomeserverClient::new() -> (in retry) signin() -> get_latest -> get_record. Total signins: 1 (Cell guards subsequent calls).
  </action>
  <verify>
`cargo build 2>&1 | grep -c warning` outputs 0. `cargo test` passes all tests. `grep -n 'get_all_records' src/commands/list.rs` shows usage. `grep -c 'get_record' src/commands/list.rs` is 0 (no individual get_record calls in list command).
  </verify>
  <done>
List command calls `get_all_records()` once instead of N individual `get_record()` calls. HomeserverClient signs in once per process. All commands use one signin per invocation regardless of how many authenticated operations follow.
  </done>
</task>

</tasks>

<verification>
1. `cargo build 2>&1 | grep warning` — must produce no output (zero warnings)
2. `cargo test` — all tests pass
3. `grep -n 'ensure_signed_in' src/transport/mod.rs` — method exists and is called from publish()
4. `grep -n 'signed_in' src/transport/mod.rs` — Cell field exists in HomeserverClient struct
5. `grep -n 'get_all_records' src/commands/list.rs` — list command uses batch method
6. `grep -c 'for.*token.*in.*tokens\|get_record.*token' src/commands/list.rs` — zero matches (no per-record loop in list command)
</verification>

<success_criteria>
- HomeserverClient has a `signed_in: Cell<bool>` field and `ensure_signed_in()` method
- `publish()` uses `ensure_signed_in()` instead of `signin()` — no redundant signin
- `get_all_records()` encapsulates list+fetch pattern in the transport layer
- `run_list()` calls `get_all_records()` once instead of looping over individual `get_record()` calls
- All existing tests pass
- Zero compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/07-code-quality-and-transport/07-02-SUMMARY.md`
</output>
