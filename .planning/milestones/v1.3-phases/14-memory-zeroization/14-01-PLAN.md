---
phase: 14-memory-zeroization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/crypto/mod.rs
  - src/keys/store.rs
autonomous: true
requirements:
  - ZERO-01
  - ZERO-02

must_haves:
  truths:
    - "ed25519_to_x25519_secret returns Zeroizing<[u8; 32]> and all callers compile via auto-deref"
    - "pin_derive_key returns Zeroizing<[u8; 32]> with argon2_output and okm zeroized internally"
    - "load_keypair reads hex key file into Zeroizing buffers — no unprotected Vec<u8> or String holding secret bytes"
    - "All existing tests pass unchanged after type changes"
  artifacts:
    - path: "Cargo.toml"
      provides: "zeroize = 1 as direct dependency"
      contains: 'zeroize = "1"'
    - path: "src/crypto/mod.rs"
      provides: "Zeroizing return types for ed25519_to_x25519_secret and pin_derive_key"
      contains: "Zeroizing<[u8; 32]>"
    - path: "src/keys/store.rs"
      provides: "Zeroizing reimplementation of load_keypair"
      contains: "Zeroizing::new"
  key_links:
    - from: "src/crypto/mod.rs"
      to: "src/commands/pickup.rs"
      via: "ed25519_to_x25519_secret return type change — callers pass to age_identity(&x25519_secret) which takes &[u8;32], auto-deref works"
      pattern: "age_identity\\(&x25519_secret\\)"
    - from: "src/crypto/mod.rs"
      to: "src/crypto/mod.rs"
      via: "pin_derive_key return type change — pin_encrypt and pin_decrypt pass result to age_identity, auto-deref works"
      pattern: "age_identity\\(&derived_key\\)"
    - from: "src/keys/store.rs"
      to: "pkarr::Keypair::from_secret_key"
      via: "Zeroizing<[u8;32]> seed passed by reference to pkarr — auto-deref provides &[u8;32]"
      pattern: "Keypair::from_secret_key\\(&seed\\)"
---

<objective>
Add `zeroize` as a direct dependency and apply `Zeroizing<T>` wrappers to all secret material in `crypto/mod.rs` and `keys/store.rs`.

Purpose: Ensure the X25519 secret scalar (ZERO-01) and decrypted key file bytes (ZERO-02) are automatically zeroed from memory when they go out of scope, eliminating the window where secret key material persists on the heap after use.

Output: `ed25519_to_x25519_secret` and `pin_derive_key` return `Zeroizing<[u8;32]>`, `load_keypair` uses `Zeroizing<String>` and `Zeroizing<[u8;32]>` for intermediate buffers, `cargo test` passes.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-memory-zeroization/14-RESEARCH.md
@Cargo.toml
@src/crypto/mod.rs
@src/keys/store.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add zeroize dependency and wrap crypto return types</name>
  <files>Cargo.toml, src/crypto/mod.rs</files>
  <action>
1. Add `zeroize = "1"` to `[dependencies]` in `Cargo.toml` (after `sha2` alphabetically).

2. In `src/crypto/mod.rs`:
   - Add `use zeroize::Zeroizing;` to the imports at the top of the file.
   - Change `ed25519_to_x25519_secret` return type from `[u8; 32]` to `Zeroizing<[u8; 32]>`. Wrap the body: `Zeroizing::new(signing_key.to_scalar_bytes())`.
   - Change `pin_derive_key` return type from `[u8; 32]` to `Zeroizing<[u8; 32]>`. Internally change `argon2_output` to `Zeroizing::new([0u8; 32])` and `okm` to `Zeroizing::new([0u8; 32])`. Pass `argon2_output.as_mut()` to `hash_password_into` and `okm.as_mut()` to `hkdf.expand`. Return `Ok(okm)`.
   - In `pin_encrypt` and `pin_decrypt`: NO changes needed — `age_identity(&derived_key)` auto-derefs from `&Zeroizing<[u8;32]>` to `&[u8;32]`.

3. Verify all callers compile:
   - `pickup.rs` (2 sites): `age_identity(&x25519_secret)` — auto-deref, no change.
   - `revoke.rs` (1 site): `age_identity(&x25519_secret)` — auto-deref, no change.
   - `list.rs` (1 site): `age_identity(&x25519_secret)` — auto-deref, no change.
   - `pin_encrypt`, `pin_decrypt`: `age_identity(&derived_key)` — auto-deref, no change.
   - Tests: `assert_eq!(scalar1, scalar2)` works because `Zeroizing<Z>` implements `PartialEq` when `Z: PartialEq`. `assert_eq!(key1, key2)` for `pin_derive_key` tests likewise works.

Note: The `test_pin_derive_key_deterministic` test asserts `key1.len() == 32`. `Zeroizing<[u8;32]>` derefs to `[u8;32]` which has `.len() == 32`. This works via `Deref`.
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/cclink && cargo test 2>&1</automated>
    <manual>Confirm Zeroizing return types in crypto/mod.rs function signatures</manual>
  </verify>
  <done>ed25519_to_x25519_secret returns Zeroizing&lt;[u8;32]&gt;, pin_derive_key returns Zeroizing&lt;[u8;32]&gt; with internal argon2_output and okm also wrapped, all existing tests pass, cargo clippy is clean</done>
</task>

<task type="auto">
  <name>Task 2: Reimplement load_keypair with zeroizing buffers</name>
  <files>src/keys/store.rs</files>
  <action>
1. In `src/keys/store.rs`:
   - Add `use zeroize::Zeroizing;` to the imports at the top.
   - Replace the `load_keypair` function body. Currently it calls `pkarr::Keypair::from_secret_key_file(&path)` which internally allocates a non-zeroized `Vec&lt;u8&gt;` for the hex-decoded secret bytes.
   - New implementation:
     a. Read the key file with `std::fs::read_to_string(&path)` wrapped in `Zeroizing::new(...)` so the hex string is wiped on drop.
     b. Trim the hex string: `let hex_trimmed = hex_string.trim();`
     c. Validate length: if `hex_trimmed.len() != 64`, bail with "Invalid secret key file: expected 64 hex chars, got N".
     d. Decode hex into `Zeroizing::new([0u8; 32])` using a manual byte-by-byte loop: for `i in 0..32`, parse `&hex_trimmed[i*2..i*2+2]` with `u8::from_str_radix(byte_str, 16)`. This avoids any intermediate `Vec&lt;u8&gt;` allocation.
     e. Call `pkarr::Keypair::from_secret_key(&seed)` to construct the keypair from the zeroized seed.
     f. Return `Ok(keypair)`. The `seed` and `hex_string` Zeroizing wrappers drop here and are zeroed.

2. Do NOT change the function signature — it still returns `anyhow::Result&lt;pkarr::Keypair&gt;`.

3. Use `anyhow::Context` (already imported) for the file read error: `.with_context(|| format!("Failed to read key file: {}", path.display()))`.

4. Use the exact hex decode pattern from the research (14-RESEARCH.md Pattern 2) — no `hex` crate, no `Vec&lt;u8&gt;`.
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/cclink && cargo test 2>&1 && cargo clippy --all-targets -- -D warnings 2>&1</automated>
    <manual>Confirm load_keypair no longer calls pkarr::Keypair::from_secret_key_file</manual>
  </verify>
  <done>load_keypair reads hex key file into Zeroizing&lt;String&gt; and decodes into Zeroizing&lt;[u8;32]&gt; — no unprotected Vec or String holds secret bytes; pkarr::from_secret_key_file is no longer called; all tests pass; clippy is clean</done>
</task>

</tasks>

<verification>
```bash
# Full test suite
cargo test

# Clippy clean
cargo clippy --all-targets -- -D warnings

# Confirm zeroize is a direct dependency
grep 'zeroize' Cargo.toml

# Confirm pkarr::from_secret_key_file is NOT called anywhere
grep -r 'from_secret_key_file' src/

# Confirm Zeroizing return types
grep 'Zeroizing<\[u8; 32\]>' src/crypto/mod.rs
grep 'Zeroizing' src/keys/store.rs
```
</verification>

<success_criteria>
- `cargo test` passes with zero failures
- `cargo clippy --all-targets -- -D warnings` exits 0
- `ed25519_to_x25519_secret` signature shows `-> Zeroizing<[u8; 32]>`
- `pin_derive_key` signature shows `-> anyhow::Result<Zeroizing<[u8; 32]>>`
- `load_keypair` contains `Zeroizing::new` for both hex string and seed array
- `pkarr::Keypair::from_secret_key_file` is not called in the codebase
- `zeroize = "1"` is present in Cargo.toml `[dependencies]`
</success_criteria>

<output>
After completion, create `.planning/phases/14-memory-zeroization/14-01-SUMMARY.md`
</output>
