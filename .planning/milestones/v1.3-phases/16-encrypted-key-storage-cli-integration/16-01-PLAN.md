---
phase: 16-encrypted-key-storage-cli-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/keys/store.rs
autonomous: true
requirements:
  - KEYS-03
  - KEYS-04
  - KEYS-06

must_haves:
  truths:
    - "write_encrypted_keypair_atomic writes a file starting with CCLINKEK magic bytes"
    - "write_encrypted_keypair_atomic sets 0600 permissions on the written file"
    - "load_keypair detects CCLINKEK magic and branches to the encrypted path"
    - "load_keypair loads a plaintext hex key file without any passphrase prompt (backward compat)"
    - "load_encrypted_keypair returns Err for wrong passphrase (not a panic)"
    - "load_encrypted_keypair returns a valid pkarr::Keypair for correct passphrase"
  artifacts:
    - path: "src/keys/store.rs"
      provides: "write_encrypted_keypair_atomic, load_keypair format detection, load_encrypted_keypair, load_plaintext_keypair"
      contains: "fn write_encrypted_keypair_atomic"
  key_links:
    - from: "src/keys/store.rs"
      to: "src/crypto/mod.rs"
      via: "decrypt_key_envelope call in load_encrypted_keypair"
      pattern: "crate::crypto::decrypt_key_envelope"
    - from: "src/keys/store.rs"
      to: "src/keys/store.rs"
      via: "format detection via starts_with(b\"CCLINKEK\")"
      pattern: "starts_with\\(b\"CCLINKEK\"\\)"
---

<objective>
Implement the encrypted key store layer: `write_encrypted_keypair_atomic` for writing CCLINKEK binary envelopes and format-detecting `load_keypair` that transparently handles both encrypted and plaintext key files.

Purpose: Phase 16 requires the store layer to read and write encrypted key files before the CLI command layer can wire passphrase prompts. This plan builds and tests the store functions that Plan 02 will call from `run_init`.

Output: Tested `write_encrypted_keypair_atomic`, refactored `load_keypair` with CCLINKEK format detection, and `load_encrypted_keypair`/`load_plaintext_keypair` private helpers.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-encrypted-key-storage-cli-integration/16-RESEARCH.md
@.planning/phases/15-encrypted-key-crypto-layer/15-01-SUMMARY.md
@src/keys/store.rs
@src/crypto/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Add failing tests for encrypted key store functions</name>
  <files>src/keys/store.rs</files>
  <action>
Add tests to the existing `#[cfg(test)] mod tests` block in `src/keys/store.rs`. These tests exercise the store layer's encrypted key handling. Import `crate::crypto::encrypt_key_envelope` in the test module.

**Test 1: `test_write_encrypted_keypair_atomic_creates_cclinkek_file`**
- Create a temp dir, generate a random keypair, call `encrypt_key_envelope(&keypair.secret_key(), "testpass1234")` to get envelope bytes
- Call `write_encrypted_keypair_atomic(&envelope, &path)` (function does not exist yet — this will fail to compile)
- Read the file back with `std::fs::read`, assert it starts with `b"CCLINKEK"`
- Assert the file contents equal the original envelope bytes exactly

**Test 2: `test_write_encrypted_keypair_atomic_sets_0600`** (cfg(unix))
- Same setup as Test 1
- After write, read metadata, assert `mode & 0o777 == 0o600`

**Test 3: `test_load_keypair_format_detection_plaintext`**
- Create a temp dir, set env or use a helper to override the key path (or test `load_plaintext_keypair` directly if made `pub(crate)`)
- Write a hex key file (use `keypair.write_secret_key_file(&path)` then set 0600)
- Call `load_plaintext_keypair(&raw_bytes)` where raw_bytes = `std::fs::read(&path)`
- Assert the loaded keypair's public key matches the original (function does not exist yet — compile failure)

**Test 4: `test_load_encrypted_keypair_round_trip`**
- Create a keypair, encrypt with `encrypt_key_envelope(&keypair.secret_key(), "testpass1234")`
- Call `load_encrypted_keypair_with_passphrase(&envelope, "testpass1234")` — a testable variant that takes the passphrase as argument instead of prompting (function does not exist yet — compile failure)
- Assert the loaded keypair's public key matches the original

**Test 5: `test_load_encrypted_keypair_wrong_passphrase`**
- Same setup as Test 4 but call with wrong passphrase `"wrongpass999"`
- Assert result is `Err` (not a panic)

**Test 6: `test_load_keypair_format_detection_encrypted`**
- Create envelope bytes via `encrypt_key_envelope`
- Assert `envelope.starts_with(b"CCLINKEK")` is true (sanity check on the format detection predicate)
- Create a plaintext hex string `"ab".repeat(32)`
- Assert `!plaintext.as_bytes().starts_with(b"CCLINKEK")` (no false positive)

**Important:** These tests reference functions that do not exist yet (`write_encrypted_keypair_atomic`, `load_plaintext_keypair`, `load_encrypted_keypair_with_passphrase`). They MUST fail to compile. Do NOT create stub implementations — that is the GREEN task.

Commit message: `test(16-01): add failing tests for encrypted key store functions (RED)`
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/cclink && cargo test --lib keys::store::tests 2>&1 | grep -E "error|cannot find"</automated>
    <manual>Confirm compilation errors reference the missing functions</manual>
  </verify>
  <done>Tests exist in store.rs that reference write_encrypted_keypair_atomic, load_plaintext_keypair, and load_encrypted_keypair_with_passphrase — compilation fails because these functions do not exist yet</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement encrypted key store functions</name>
  <files>src/keys/store.rs</files>
  <action>
Implement the following functions in `src/keys/store.rs` to make all RED tests pass.

**1. `pub fn write_encrypted_keypair_atomic(envelope: &[u8], dest: &Path) -> anyhow::Result<()>`**

Following the exact pattern from `write_keypair_atomic` but writing raw bytes instead of calling `keypair.write_secret_key_file`:
- Get parent dir, compute tmp path as `parent.join(".secret_key.tmp")`
- `std::fs::write(&tmp, envelope)` — write raw envelope bytes (not hex)
- Set 0600 on the temp file BEFORE rename (minimize insecure window):
  ```rust
  #[cfg(unix)]
  {
      use std::os::unix::fs::PermissionsExt;
      std::fs::set_permissions(&tmp, std::fs::Permissions::from_mode(0o600))?;
  }
  ```
- `std::fs::rename(&tmp, dest)` — atomic replacement. On failure, remove tmp and return error
- Set 0600 again on dest after rename for defense-in-depth (same as `write_keypair_atomic`)
- Map errors to `CclinkError::AtomicWriteFailed`

**2. Refactor `load_keypair` — format detection**

Change `load_keypair` to:
- Read file with `std::fs::read(&path)` (returns `Vec<u8>`, NOT `read_to_string` — binary files are not valid UTF-8)
- Check `raw.starts_with(b"CCLINKEK")`:
  - If true: call `load_encrypted_keypair(&raw)` (the interactive prompt version)
  - If false: call `load_plaintext_keypair(&raw)` (the existing hex-decode logic)

**3. `fn load_plaintext_keypair(raw: &[u8]) -> anyhow::Result<pkarr::Keypair>`**

Extract the existing hex-decode logic from `load_keypair` into this private function:
- Convert raw bytes to string: `let hex_string = Zeroizing::new(String::from_utf8(raw.to_vec()).context("Key file is not valid UTF-8")?);`
- Trim, validate 64 chars, decode hex byte-by-byte into `Zeroizing<[u8;32]>` (exact existing logic)
- Return `pkarr::Keypair::from_secret_key(&seed)`

**4. `fn load_encrypted_keypair(envelope: &[u8]) -> anyhow::Result<pkarr::Keypair>`**

The interactive version called from `load_keypair` — prompts for passphrase via dialoguer:
- Guard: `if !std::io::stdin().is_terminal() { anyhow::bail!("Encrypted keypair requires interactive terminal for passphrase entry"); }`
- Prompt: `Zeroizing::new(dialoguer::Password::new().with_prompt("Enter key passphrase").interact().map_err(|e| anyhow::anyhow!("Passphrase prompt failed: {}", e))?)`
- Call `load_encrypted_keypair_with_passphrase(envelope, &passphrase)`

**5. `fn load_encrypted_keypair_with_passphrase(envelope: &[u8], passphrase: &str) -> anyhow::Result<pkarr::Keypair>`**

The testable core (no I/O, no terminal dependency):
- `match crate::crypto::decrypt_key_envelope(envelope, passphrase)`:
  - `Ok(seed)` => `Ok(pkarr::Keypair::from_secret_key(&seed))`
  - `Err(_)` => `eprintln!("Wrong passphrase"); std::process::exit(1);`

**Wait — the test expects `Err`, not `process::exit(1)`.** For testability, `load_encrypted_keypair_with_passphrase` should return the `Err` from `decrypt_key_envelope` so tests can assert on it. The `eprintln! + process::exit(1)` pattern should be in `load_encrypted_keypair` (the interactive wrapper), which catches the `Err` from `load_encrypted_keypair_with_passphrase` and converts it to the hard exit.

Revised approach:
- `load_encrypted_keypair_with_passphrase`: Returns `Ok(Keypair)` on success, propagates `Err` from `decrypt_key_envelope` on failure
- `load_encrypted_keypair`: Calls `load_encrypted_keypair_with_passphrase`, on `Err` does `eprintln!("Wrong passphrase"); std::process::exit(1);`

This way tests can call `load_encrypted_keypair_with_passphrase` directly and assert on `Err`, while the production `load_keypair -> load_encrypted_keypair` path uses the hard exit (matching KEYS-04).

**6. Remove `#[allow(dead_code)]` from crypto functions**

In `src/crypto/mod.rs`, remove `#[allow(dead_code)]` from `encrypt_key_envelope`, `decrypt_key_envelope`, `key_derive_key`, and the constants (`ENVELOPE_MAGIC`, `ENVELOPE_VERSION`, `ENVELOPE_HEADER_LEN`, `KEY_HKDF_INFO`, `KDF_M_COST`, `KDF_T_COST`, `KDF_P_COST`) — these are now called from `store.rs` (directly or transitively via tests). Only remove the annotations for items that are actually used after the store.rs changes; if any remain unused, keep their annotation.

**Important:** Run `cargo clippy --all-targets -- -D warnings` and fix any new warnings before committing.

Commit message: `feat(16-01): implement encrypted key store functions (GREEN)`
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/cclink && cargo test --lib keys::store::tests -- --nocapture && cargo clippy --all-targets -- -D warnings</automated>
    <manual>All 6 new tests pass, all existing tests still pass, clippy clean</manual>
  </verify>
  <done>write_encrypted_keypair_atomic writes CCLINKEK files with 0600 permissions; load_keypair detects format and branches; load_plaintext_keypair handles hex; load_encrypted_keypair_with_passphrase decrypts and returns Keypair or Err; all tests pass and clippy is clean</done>
</task>

</tasks>

<verification>
All Phase 16 Plan 01 verification:
1. `cargo test --lib keys::store::tests` — all new and existing store tests pass
2. `cargo test` — full test suite passes (no regressions)
3. `cargo clippy --all-targets -- -D warnings` — no warnings
4. `cargo fmt --check` — formatted correctly
</verification>

<success_criteria>
- `write_encrypted_keypair_atomic` writes binary envelope to disk with 0600 permissions
- `load_keypair` transparently detects CCLINKEK magic and branches to encrypted path
- Plaintext hex key files load without passphrase prompt (backward compatibility)
- Encrypted key files decrypt with correct passphrase and return valid Keypair
- Wrong passphrase returns Err from the testable function (interactive wrapper converts to exit(1))
- All tests pass, clippy clean, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/16-encrypted-key-storage-cli-integration/16-01-SUMMARY.md`
</output>
