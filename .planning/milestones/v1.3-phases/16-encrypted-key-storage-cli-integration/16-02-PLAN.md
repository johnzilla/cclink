---
phase: 16-encrypted-key-storage-cli-integration
plan: 02
type: execute
wave: 2
depends_on:
  - "16-01"
files_modified:
  - src/cli.rs
  - src/commands/init.rs
autonomous: true
requirements:
  - KEYS-01
  - KEYS-02

must_haves:
  truths:
    - "cclink init prompts for a passphrase with confirmation and writes an encrypted key file"
    - "cclink init --no-passphrase skips the prompt and writes a plaintext hex key file"
    - "Passphrase shorter than 8 characters is rejected with a clear error"
    - "Imported keys (--import) respect the --no-passphrase flag the same as generated keys"
    - "Non-interactive terminal with no --no-passphrase flag produces a clear error"
  artifacts:
    - path: "src/cli.rs"
      provides: "--no-passphrase flag on InitArgs"
      contains: "no_passphrase"
    - path: "src/commands/init.rs"
      provides: "Passphrase prompt flow, encrypt-or-plaintext write branching"
      contains: "encrypt_key_envelope"
  key_links:
    - from: "src/commands/init.rs"
      to: "src/crypto/mod.rs"
      via: "encrypt_key_envelope call for seed encryption"
      pattern: "crate::crypto::encrypt_key_envelope"
    - from: "src/commands/init.rs"
      to: "src/keys/store.rs"
      via: "write_encrypted_keypair_atomic for encrypted path, write_keypair_atomic for plaintext path"
      pattern: "store::write_encrypted_keypair_atomic"
    - from: "src/cli.rs"
      to: "src/commands/init.rs"
      via: "InitArgs.no_passphrase field consumed in run_init"
      pattern: "args\\.no_passphrase"
---

<objective>
Wire the passphrase prompt and `--no-passphrase` flag into `cclink init` so users can create passphrase-protected or plaintext keypairs. Both generated and imported keys go through the same encrypt-or-skip logic.

Purpose: This is the user-facing integration that makes encrypted key storage real. Plan 01 built the store layer; this plan connects it to the CLI.

Output: Updated `src/cli.rs` with `--no-passphrase` flag, updated `src/commands/init.rs` with passphrase prompt flow, encrypted key write path, and plaintext fallback.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-encrypted-key-storage-cli-integration/16-RESEARCH.md
@.planning/phases/16-encrypted-key-storage-cli-integration/16-01-SUMMARY.md
@src/cli.rs
@src/commands/init.rs
@src/keys/store.rs
@src/crypto/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --no-passphrase CLI flag and passphrase prompt flow in run_init</name>
  <files>src/cli.rs, src/commands/init.rs</files>
  <action>
**In `src/cli.rs`:**

Add `no_passphrase` field to `InitArgs`:
```rust
#[derive(Parser)]
pub struct InitArgs {
    /// Import an existing keypair from file path or stdin (use - for stdin)
    #[arg(long, value_name = "PATH")]
    pub import: Option<String>,

    /// Skip overwrite confirmation prompt
    #[arg(long, short = 'y')]
    pub yes: bool,

    /// Write a plaintext (unencrypted) key file, skipping the passphrase prompt
    #[arg(long)]
    pub no_passphrase: bool,
}
```

**In `src/commands/init.rs`:**

Add necessary imports at the top:
- `use std::io::IsTerminal;` (already imported as `use std::io::{self, IsTerminal, Read, Write};`)
- `use zeroize::Zeroizing;`

Replace the current "Step 5: Write keypair atomically" section in `run_init` with the encrypt-or-plaintext branching logic. The new Step 5 replaces the single `write_keypair_atomic` call:

```rust
// Step 5: Write keypair — encrypted (default) or plaintext (--no-passphrase)
if args.no_passphrase {
    // Plaintext path (v1.2-compatible)
    store::write_keypair_atomic(&keypair, &secret_key_path)
        .context("Failed to write keypair")?;
} else {
    // Encrypted path (v1.3 default)
    if !io::stdin().is_terminal() {
        anyhow::bail!("Use --no-passphrase for non-interactive init");
    }
    let passphrase = Zeroizing::new(
        dialoguer::Password::new()
            .with_prompt("Enter key passphrase (min 8 chars)")
            .with_confirmation("Confirm passphrase", "Passphrases don't match")
            .interact()
            .map_err(|e| anyhow::anyhow!("Passphrase prompt failed: {}", e))?,
    );
    if passphrase.len() < 8 {
        eprintln!("Error: Passphrase must be at least 8 characters");
        std::process::exit(1);
    }
    let seed: [u8; 32] = keypair.secret_key();
    let envelope = crate::crypto::encrypt_key_envelope(&seed, &passphrase)?;
    store::write_encrypted_keypair_atomic(&envelope, &secret_key_path)
        .context("Failed to write encrypted keypair")?;
}
```

**Key details:**
- `keypair.secret_key()` returns `[u8; 32]` — this is the raw Ed25519 seed
- `encrypt_key_envelope` takes `&[u8; 32]` and `&str`; `Zeroizing<String>` auto-derefs to `&str`
- `write_encrypted_keypair_atomic` is the function from Plan 01
- The passphrase validation (`len < 8`) fires AFTER the user types it twice (confirmation); this avoids prompting again
- Use `eprintln!` + `process::exit(1)` for the too-short error (not `anyhow::bail!`) to match the project pattern from Phase 13 (PIN validation) — avoids the "Error: Error:" double prefix
- The `--import` path flows into the same Step 5 logic: `--import` determines the *source* of the keypair, `--no-passphrase` determines whether to encrypt the *output*
- Non-interactive terminal without `--no-passphrase` bails with a clear message ("Use --no-passphrase for non-interactive init")

**Update the "Step 6: Success output" section** to reflect encryption status:
- After the write, add a line indicating whether the key was encrypted:
  ```rust
  if args.no_passphrase {
      println!("Key file:    {} (plaintext)", secret_key_path.display());
  } else {
      println!("Key file:    {} (passphrase-protected)", secret_key_path.display());
  }
  ```
  Replace the existing `println!("Key file:    {}", secret_key_path.display());` line.

**Update `prompt_overwrite` to handle encrypted existing keys:**
- The current `pkarr::Keypair::from_secret_key_file(existing_key_path)` will fail on encrypted files. The fallback `"(unreadable)"` is acceptable per research, but improve it: read first 8 bytes, if they match `b"CCLINKEK"`, show `"(encrypted)"` as the identifier instead of `"(unreadable)"`. This is a low-effort UX improvement:
  ```rust
  let identifier = if std::fs::read(existing_key_path)
      .map(|raw| raw.starts_with(b"CCLINKEK"))
      .unwrap_or(false)
  {
      "(encrypted)".to_string()
  } else {
      match pkarr::Keypair::from_secret_key_file(existing_key_path) {
          Ok(kp) => fingerprint::short_fingerprint(&kp.public_key()),
          Err(_) => "(unreadable)".to_string(),
      }
  };
  ```

**Run `cargo clippy --all-targets -- -D warnings`** and fix any warnings. In particular, verify that `#[allow(dead_code)]` on `encrypt_key_envelope` in `crypto/mod.rs` can now be removed since it is called from `init.rs`. If `decrypt_key_envelope` annotations were already removed in Plan 01 (called from store.rs), verify no regressions. Remove any remaining `#[allow(dead_code)]` on crypto items that are now reachable.

Commit message: `feat(16-02): wire passphrase prompt and --no-passphrase flag into cclink init`
  </action>
  <verify>
    <automated>cd /home/john/vault/projects/github.com/cclink && cargo build && cargo test && cargo clippy --all-targets -- -D warnings && cargo fmt --check</automated>
    <manual>Verify `cclink init --help` shows --no-passphrase flag; verify that `cargo build` succeeds with no dead_code warnings on crypto functions</manual>
  </verify>
  <done>cclink init prompts for passphrase by default and writes encrypted CCLINKEK file; --no-passphrase skips prompt and writes plaintext hex; --import respects the same flag; non-interactive terminal without --no-passphrase produces a clear error; passphrase shorter than 8 chars is rejected; all tests pass and clippy is clean</done>
</task>

</tasks>

<verification>
All Phase 16 Plan 02 verification:
1. `cargo build` — compiles cleanly
2. `cargo test` — full test suite passes (no regressions)
3. `cargo clippy --all-targets -- -D warnings` — no warnings, no dead_code annotations on active crypto functions
4. `cargo fmt --check` — formatted correctly
5. `cclink init --help` shows `--no-passphrase` flag with description
</verification>

<success_criteria>
- `cclink init` prompts for passphrase with confirmation (dialoguer::Password) and writes encrypted CCLINKEK file
- `cclink init --no-passphrase` skips prompt and writes plaintext hex file (v1.2-compatible)
- Passphrase under 8 characters is rejected with clear error and exit code 1
- Imported keys (`--import`) respect `--no-passphrase` flag identically to generated keys
- Non-interactive terminal without `--no-passphrase` bails with "Use --no-passphrase for non-interactive init"
- Overwrite prompt shows `(encrypted)` for existing CCLINKEK files instead of `(unreadable)`
- No `#[allow(dead_code)]` remains on actively-used crypto functions
- All tests pass, clippy clean, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/16-encrypted-key-storage-cli-integration/16-02-SUMMARY.md`
</output>
