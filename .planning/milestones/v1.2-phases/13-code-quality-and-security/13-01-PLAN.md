---
phase: 13-code-quality-and-security
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/commands/publish.rs
autonomous: true
requirements:
  - PIN-01

must_haves:
  truths:
    - "A PIN shorter than 8 characters is rejected with a clear error showing the character count"
    - "An all-same-character PIN (e.g. 00000000) is rejected with 'all characters are the same' reason"
    - "A sequential PIN (e.g. 12345678, abcdefgh, 87654321) is rejected with 'sequential pattern' reason"
    - "A common word PIN (e.g. password, qwerty) is rejected with 'common word or pattern' reason"
    - "A valid 8+ character PIN that passes all checks proceeds to pin_encrypt without error"
    - "PIN validation fires after the user types the PIN but before any network call or encryption"
  artifacts:
    - path: "src/commands/publish.rs"
      provides: "validate_pin function and integration into run_publish PIN branch"
      contains: "fn validate_pin"
  key_links:
    - from: "src/commands/publish.rs validate_pin"
      to: "dialoguer::Password::interact() return value"
      via: "called immediately after interact() returns, before pin_encrypt"
      pattern: "validate_pin.*&pin"
---

<objective>
Enforce PIN strength validation at publish time with TDD.

Purpose: Prevent weak PINs (too short, all-same, sequential, common words) from being used for handoff encryption, matching NIST 800-63B-4 guidance (length + blocklist, no complexity rules).

Output: A `validate_pin` function in `publish.rs` with comprehensive tests, wired into the PIN branch of `run_publish` so weak PINs are rejected before any network call.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-code-quality-and-security/13-RESEARCH.md
@src/commands/publish.rs
@src/main.rs
@src/error.rs
</context>

<feature>
  <name>PIN strength validation</name>
  <files>src/commands/publish.rs</files>
  <behavior>
    validate_pin(pin: &amp;str) -> Result&lt;(), String&gt;

    Cases:
    - "1234567" (7 chars) -> Err("PIN must be at least 8 characters (got 7)")
    - "abc" (3 chars) -> Err("PIN must be at least 8 characters (got 3)")
    - "00000000" -> Err("PIN rejected: all characters are the same")
    - "aaaaaaaa" -> Err("PIN rejected: all characters are the same")
    - "12345678" ascending -> Err("PIN rejected: sequential pattern")
    - "abcdefgh" ascending -> Err("PIN rejected: sequential pattern")
    - "87654321" descending -> Err("PIN rejected: sequential pattern")
    - "hgfedcba" descending -> Err("PIN rejected: sequential pattern")
    - "password" -> Err("PIN rejected: common word or pattern")
    - "qwerty" -> also caught by length check first (6 chars), but "qwertyui" (8 chars) -> Err("PIN rejected: common word or pattern")
    - "MyS3cur3P1n!" -> Ok(())
    - "validpin" -> Ok(()) (8 chars, not all-same, not sequential, not in common list)
    - "12345679" -> Ok(()) (not perfectly sequential — last char breaks pattern)

    Integration: After dialoguer::Password::interact() returns in the cli.pin branch of run_publish, call validate_pin(&amp;pin). On Err(reason), print using the existing error pattern (eprintln! with red "Error:" prefix via owo_colors) and call std::process::exit(1). Do NOT use anyhow::bail! — main() returns anyhow::Result which would double-print the error.

    Common word list (~17 entries): password, qwerty, letmein, welcome, monkey, dragon, master, iloveyou, sunshine, princess, football, baseball, 123456789, 12345678, 87654321, qwertyui, asdfghjk
  </behavior>
  <implementation>
    1. Add `fn validate_pin(pin: &amp;str) -> Result&lt;(), String&gt;` at module level in publish.rs.

    2. Validation rules in order:
       a. Length check: pin.len() &lt; 8 -> Err with character count
       b. All-same check: pin.chars().all(|c| c == first) -> Err
       c. Sequential check: chars.windows(2) arithmetic for ascending (diff == 1) and descending (diff == -1) -> Err
       d. Common word check: lowercase match against COMMON const slice -> Err

    3. Wire into run_publish: insert between line 101 (.interact()?) and line 103 (pin_encrypt). On validation failure:
       ```rust
       if let Err(reason) = validate_pin(&amp;pin) {
           eprintln!(
               "{} {}",
               "Error:".if_supports_color(Stderr, |t| t.red()),
               reason
           );
           std::process::exit(1);
       }
       ```

    4. Unit tests go in a `#[cfg(test)] mod tests` block at the bottom of publish.rs (the file does not currently have a tests module).
  </implementation>
</feature>

<verification>
- `cargo test --lib -- publish::tests` runs all PIN validation unit tests (RED phase: all fail; GREEN phase: all pass)
- `cargo build` succeeds with no warnings
- `cargo clippy --all-targets -- -D warnings` exits 0
- `cargo fmt --check` exits 0
</verification>

<success_criteria>
- validate_pin rejects PINs shorter than 8 characters with exact count in error message
- validate_pin rejects all-same-character PINs
- validate_pin rejects ascending and descending sequential PINs
- validate_pin rejects common word PINs (case-insensitive)
- validate_pin accepts valid PINs of 8+ characters
- Validation is wired into run_publish between interact() and pin_encrypt()
- Error output uses eprintln! + process::exit(1), not anyhow::bail!
- All existing tests still pass (cargo test)
</success_criteria>

<output>
After completion, create `.planning/phases/13-code-quality-and-security/13-01-SUMMARY.md`
</output>
