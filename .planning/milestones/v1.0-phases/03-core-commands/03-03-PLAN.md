---
phase: 03-core-commands
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/commands/pickup.rs
autonomous: true
requirements:
  - RET-01
  - RET-02
  - RET-03
  - RET-04
  - RET-05
  - RET-06
  - UX-01

must_haves:
  truths:
    - "Running `cclink pickup` retrieves and decrypts the user's own latest handoff, shows confirmation, and launches claude --resume"
    - "Running `cclink pickup <pubkey>` retrieves another user's handoff; shows cleartext metadata but notes decryption is not possible without --share"
    - "Expired records are refused with a human-readable message showing how long ago they expired"
    - "Running `cclink pickup --yes` skips the confirmation prompt and launches immediately"
    - "Running `cclink pickup --qr` displays a QR code of the decrypted session ID"
    - "Network failures retry 3 times with exponential backoff before failing"
    - "All output uses colored text: green for success, red for errors, yellow for warnings"
    - "On Unix, `claude --resume <id>` replaces the cclink process via exec()"
  artifacts:
    - path: "src/commands/pickup.rs"
      provides: "Pickup command with retrieval, decryption, TTL check, retry, confirmation, exec"
      exports: ["run_pickup"]
      min_lines: 100
  key_links:
    - from: "src/commands/pickup.rs"
      to: "src/transport/mod.rs"
      via: "HomeserverClient::get_latest() and get_record()/get_record_by_pubkey()"
      pattern: "client\\.get_latest|client\\.get_record"
    - from: "src/commands/pickup.rs"
      to: "src/crypto/mod.rs"
      via: "crypto::age_decrypt for session ID decryption"
      pattern: "crypto::age_decrypt"
    - from: "src/commands/pickup.rs"
      to: "claude --resume"
      via: "std::process::Command with Unix exec()"
      pattern: "Command::new.*claude.*--resume"
---

<objective>
Implement the `cclink pickup` command: retrieve the latest handoff from the homeserver, verify signature, check TTL, decrypt session ID, show confirmation prompt, and exec `claude --resume`.

Purpose: This delivers the second half of the core product value — a user runs `cclink pickup` on another machine and resumes their Claude Code session.

Output: `src/commands/pickup.rs` with full retrieval, decryption, TTL enforcement, retry/backoff, confirmation prompt, QR display, and process exec.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-commands/03-RESEARCH.md
@.planning/phases/03-core-commands/03-02-SUMMARY.md
@src/cli.rs
@src/commands/pickup.rs
@src/crypto/mod.rs
@src/record/mod.rs
@src/transport/mod.rs
@src/keys/store.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement pickup retrieval with retry, TTL check, and cross-user handling</name>
  <files>src/commands/pickup.rs</files>
  <action>
Replace the stub in `src/commands/pickup.rs` with the full pickup implementation.

**`run_pickup(args: PickupArgs) -> anyhow::Result<()>` flow:**

1. **Load keypair and homeserver:**
   ```rust
   let keypair = crate::keys::store::load_keypair()?;
   let homeserver = crate::keys::store::read_homeserver()?;
   let client = crate::transport::HomeserverClient::new(&homeserver)?;
   ```

2. **Determine if self-pickup or cross-user (RET-01 + RET-02):**
   - If `args.pubkey` is `None`: own pickup. Use `client.get_latest(None)` to get latest pointer, then `client.get_record(&token, &keypair.public_key())`.
   - If `args.pubkey` is `Some(pk_z32)`: cross-user pickup. Use `client.get_latest(Some(&pk_z32))`, then `client.get_record_by_pubkey(&pk_z32, &token, &parsed_pubkey)`. Parse the z32 pubkey via `pkarr::PublicKey::try_from(pk_z32.as_str())`.

3. **Wrap retrieval in retry with backoff (RET-06):**
   Use `backoff::retry()` with `ExponentialBackoff`:
   ```rust
   use backoff::{retry, ExponentialBackoff, Error as BackoffError};
   use std::time::Duration;

   let backoff_config = ExponentialBackoff {
       max_elapsed_time: Some(Duration::from_secs(30)),
       max_interval: Duration::from_secs(8),
       initial_interval: Duration::from_secs(2),
       ..Default::default()
   };
   ```
   Map 404/"not found" errors to `BackoffError::permanent()` so they fail immediately. Map other network errors to `BackoffError::transient()`.

   The retry wraps both `get_latest()` and `get_record()` — if the latest pointer is found but the record GET fails transiently, we retry the full sequence.

4. **Deserialize the latest pointer:**
   Parse `get_latest()` bytes as `serde_json::from_slice::<crate::record::LatestPointer>()`. Extract `token` field.

5. **TTL expiry check (RET-03):**
   After retrieving the record, check TTL:
   ```rust
   let now_secs = SystemTime::now()
       .duration_since(SystemTime::UNIX_EPOCH)
       .map(|d| d.as_secs())
       .unwrap_or(0);
   let expires_at = record.created_at.saturating_add(record.ttl);
   if now_secs >= expires_at {
       let expired_secs = now_secs.saturating_sub(expires_at);
       let expired_human = human_duration(expired_secs);
       anyhow::bail!("This handoff expired {} ago. Publish a new one with cclink.", expired_human);
   }
   ```
   Implement `human_duration(secs: u64) -> String`: "Xh" if >= 3600, "Xm" if >= 60, "Xs" otherwise.

   Print TTL error in red using `owo_colors`.

6. **Decrypt session ID (RET-01) or show metadata (RET-02):**
   - **Self-pickup** (pubkey matches own): Decrypt the blob:
     ```rust
     let ciphertext = base64::engine::general_purpose::STANDARD.decode(&record.blob)?;
     let x25519_secret = crate::crypto::ed25519_to_x25519_secret(&keypair);
     let identity = crate::crypto::age_identity(&x25519_secret);
     let plaintext = crate::crypto::age_decrypt(&ciphertext, &identity)?;
     let session_id = String::from_utf8(plaintext)?;
     ```
   - **Cross-user pickup** (pubkey differs from own): Cannot decrypt. Print cleartext metadata:
     ```rust
     println!("Handoff from {}", record.pubkey);
     println!("  Host: {}", record.hostname);
     println!("  Project: {}", record.project);
     println!("  Created: {} ago", human_duration(now_secs.saturating_sub(record.created_at)));
     println!("{}", "Decryption requires the creator's key. Use `--share` for shared handoffs (Phase 4).".if_supports_color(Stdout, |t| t.yellow()));
     return Ok(());
     ```

7. **Confirmation prompt (per CONTEXT.md — default behavior):**
   Compute `human_age` = how long ago the record was created.
   ```rust
   let age_secs = now_secs.saturating_sub(record.created_at);
   let human_age = human_duration(age_secs);
   ```

   If `args.yes` is false AND stdin is a terminal:
   ```rust
   use dialoguer::Confirm;
   let confirmed = Confirm::new()
       .with_prompt(format!(
           "Resume session {} ({}) published {} ago?",
           &session_id[..8.min(session_id.len())],
           record.project,
           human_age
       ))
       .default(true)
       .interact()?;
   if !confirmed {
       println!("Aborted.");
       return Ok(());
   }
   ```
   If `args.yes` is true OR stdin is not a terminal: skip confirmation.

8. **Optional QR code (RET-05):**
   ```rust
   if args.qr {
       qr2term::print_qr(&session_id)
           .map_err(|e| anyhow::anyhow!("QR code render failed: {}", e))?;
   }
   ```

9. **Launch claude --resume (RET-04):**
   Print success message, then exec:
   ```rust
   println!("{}", format!("Resuming session {}...", &session_id[..8.min(session_id.len())])
       .if_supports_color(Stdout, |t| t.green()));
   launch_claude_resume(&session_id)?;
   ```

   **`launch_claude_resume()` helper:**
   ```rust
   fn launch_claude_resume(session_id: &str) -> anyhow::Result<()> {
       let mut cmd = std::process::Command::new("claude");
       cmd.arg("--resume").arg(session_id);

       #[cfg(unix)]
       {
           use std::os::unix::process::CommandExt;
           let err = cmd.exec();
           // exec() only returns if it failed
           Err(anyhow::anyhow!("failed to exec claude: {}", err))
       }
       #[cfg(not(unix))]
       {
           let status = cmd.status()?;
           if !status.success() {
               anyhow::bail!("claude exited with status {}", status);
           }
           Ok(())
       }
   }
   ```

**Colored output throughout (UX-01):**
- Use `owo_colors::Stream::Stdout` for stdout coloring, `Stream::Stderr` for stderr
- Green: success messages, session ID display
- Red: errors (TTL expired, network failures)
- Yellow: warnings (cross-user decryption limitation, no sessions)
- Cyan: informational (project path, hostname)

Run `cargo check` and `cargo test` to verify.
  </action>
  <verify>`cargo check` succeeds; `cargo test` passes all existing tests; `cargo build` produces a binary where `cclink pickup --help` shows [PUBKEY], --yes/-y, --qr</verify>
  <done>Pickup command fully implemented: retrieves latest pointer, fetches and verifies record with retry/backoff, checks TTL expiry, decrypts session ID (self) or shows metadata (cross-user), shows confirmation prompt, renders optional QR code, and execs `claude --resume`. All output is colored.</done>
</task>

<task type="auto">
  <name>Task 2: Final integration verification and docs commit message</name>
  <files>src/commands/pickup.rs</files>
  <action>
Run a full integration check:

1. `cargo build` must succeed with no warnings (add `#![allow(unused)]` only if there are temporarily unused imports — remove before final commit)
2. `cargo test` must pass all existing tests (Phase 1 + Phase 2 tests: all 21+ should pass)
3. `cargo clippy` — fix any lint warnings in the new pickup.rs file
4. Verify the binary responds correctly to all help outputs:
   - `./target/debug/cclink --help`
   - `./target/debug/cclink pickup --help`
   - `./target/debug/cclink init --help`
   - `./target/debug/cclink whoami --help`

If any clippy warnings or compiler warnings exist in `src/commands/pickup.rs`, fix them.

Ensure the `todo!()` stub in pickup.rs is fully replaced — no `todo!()` macros should remain in the codebase.
  </action>
  <verify>`cargo build` succeeds with no warnings; `cargo test` passes all tests; `cargo clippy` has no warnings in src/commands/pickup.rs; `grep -r 'todo!' src/` returns no matches</verify>
  <done>Full Phase 3 codebase compiles cleanly, all tests pass, no clippy warnings, no remaining todo stubs. Both publish and pickup commands are wired and ready for end-to-end testing against a live homeserver.</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds — full binary compiles with publish + pickup commands
2. `cargo test` passes — all Phase 1 + Phase 2 + any new tests pass
3. `cargo clippy` clean — no warnings in new code
4. `cclink pickup --help` shows [PUBKEY], --yes/-y, --qr
5. `src/commands/pickup.rs` contains retry logic with `backoff::retry()`
6. `src/commands/pickup.rs` contains TTL expiry check with human-readable duration
7. `src/commands/pickup.rs` contains `launch_claude_resume()` with `#[cfg(unix)]` exec()
8. `src/commands/pickup.rs` contains dialoguer confirmation prompt with TTY guard
9. No `todo!()` macros remain in codebase
</verification>

<success_criteria>
The pickup command is fully wired: `cclink pickup` retrieves, decrypts, and launches `claude --resume`. TTL is enforced. Cross-user pickup shows metadata with a clear limitation message. Retry/backoff handles transient network failures. The full publish-to-pickup loop is code-complete.
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-commands/03-03-SUMMARY.md`
</output>
