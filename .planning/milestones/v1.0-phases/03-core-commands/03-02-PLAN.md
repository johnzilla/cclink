---
phase: 03-core-commands
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/cli.rs
  - src/commands/mod.rs
  - src/commands/publish.rs
  - src/main.rs
autonomous: true
requirements:
  - SESS-01
  - SESS-02
  - PUB-01
  - PUB-04
  - PUB-06
  - UX-01

must_haves:
  truths:
    - "Running `cclink` with no arguments discovers the most recent session and publishes it"
    - "Running `cclink <session-id>` publishes the specified session without discovery"
    - "Running `cclink --ttl 3600` sets a 1-hour TTL instead of the 24h default"
    - "Running `cclink --qr` renders a terminal QR code after publishing"
    - "If multiple active sessions exist, user is prompted to pick one via interactive selector"
    - "Success output is green; includes a copyable `cclink pickup <token>` command and TTL expiry"
    - "If no session is found, a helpful red error message guides the user"
  artifacts:
    - path: "src/cli.rs"
      provides: "Restructured CLI with optional subcommand and publish args at top level"
      contains: "command: Option<Commands>"
    - path: "src/commands/publish.rs"
      provides: "Publish command implementation"
      exports: ["run_publish"]
      min_lines: 60
    - path: "src/commands/mod.rs"
      provides: "Module registry including publish"
      contains: "pub mod publish"
    - path: "src/main.rs"
      provides: "Updated main dispatch with None => run_publish"
      contains: "None => commands::publish::run_publish"
  key_links:
    - from: "src/commands/publish.rs"
      to: "src/session/mod.rs"
      via: "session::discover_sessions()"
      pattern: "session::discover_sessions"
    - from: "src/commands/publish.rs"
      to: "src/crypto/mod.rs"
      via: "crypto::age_encrypt for session ID encryption"
      pattern: "crypto::age_encrypt"
    - from: "src/commands/publish.rs"
      to: "src/transport/mod.rs"
      via: "HomeserverClient::publish() for record upload"
      pattern: "client\\.publish"
    - from: "src/main.rs"
      to: "src/commands/publish.rs"
      via: "None arm in match cli.command"
      pattern: "None =>.*run_publish"
---

<objective>
Restructure the CLI to support default publish behavior (no subcommand required) and implement the full `cclink` publish command: session discovery, encryption, record signing, homeserver upload, colored output, and optional QR code.

Purpose: This delivers the first half of the core product value — a user runs `cclink` and their session is discovered, encrypted, and published.

Output: Restructured `src/cli.rs`, new `src/commands/publish.rs`, updated `src/main.rs` dispatch.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-commands/03-RESEARCH.md
@.planning/phases/03-core-commands/03-01-SUMMARY.md
@src/cli.rs
@src/commands/mod.rs
@src/main.rs
@src/session/mod.rs
@src/crypto/mod.rs
@src/record/mod.rs
@src/transport/mod.rs
@src/keys/store.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure CLI for optional subcommand with publish args at top level</name>
  <files>src/cli.rs, src/main.rs, src/commands/mod.rs</files>
  <action>
**Rewrite `src/cli.rs`** to use the `Option<Commands>` pattern for optional subcommands. When no subcommand is provided, the binary runs the publish flow. Publish arguments (session_id, --ttl, --qr) live at the top level of the `Cli` struct.

```rust
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "cclink", version, about = "Secure session handoff via Pubky")]
pub struct Cli {
    /// Optional session ID to publish (auto-discovers most recent if omitted)
    #[arg(value_name = "SESSION_ID")]
    pub session_id: Option<String>,

    /// Time-to-live in seconds (default: 86400 = 24 hours)
    #[arg(long, default_value = "86400")]
    pub ttl: u64,

    /// Render a QR code in the terminal after publish
    #[arg(long)]
    pub qr: bool,

    #[command(subcommand)]
    pub command: Option<Commands>,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Initialize or import a PKARR keypair
    Init(InitArgs),
    /// Show identity (public key, homeserver, fingerprint)
    Whoami,
    /// Pick up a session handoff from the homeserver
    Pickup(PickupArgs),
}

// Keep existing InitArgs as-is

#[derive(Parser)]
pub struct PickupArgs {
    /// z32-encoded public key of the handoff publisher (defaults to own key)
    #[arg(value_name = "PUBKEY")]
    pub pubkey: Option<String>,

    /// Skip confirmation prompt and launch immediately
    #[arg(long, short = 'y')]
    pub yes: bool,

    /// Render a QR code showing the session ID
    #[arg(long)]
    pub qr: bool,
}
```

NOTE: Default TTL is 86400 (24 hours) per user decision in CONTEXT.md — this overrides the 8-hour value in REQUIREMENTS.md.

**Update `src/main.rs`** to dispatch on `Option<Commands>`:

```rust
match cli.command {
    Some(Commands::Init(args)) => commands::init::run_init(args)?,
    Some(Commands::Whoami) => commands::whoami::run_whoami()?,
    Some(Commands::Pickup(args)) => commands::pickup::run_pickup(args)?,
    None => commands::publish::run_publish(&cli)?,
}
```

**Update `src/commands/mod.rs`** to register publish and pickup modules:
```rust
pub mod init;
pub mod pickup;
pub mod publish;
pub mod whoami;
```

Note: `commands/pickup.rs` will be created as a stub with `pub fn run_pickup(_args: crate::cli::PickupArgs) -> anyhow::Result<()> { todo!("pickup implemented in plan 03-03") }` so the project compiles.

Run `cargo check` to verify the CLI restructure compiles.
  </action>
  <verify>`cargo check` succeeds; `cclink --help` shows the new args (session_id, --ttl, --qr) and subcommands (init, whoami, pickup)</verify>
  <done>CLI restructured: `cclink` defaults to publish, `cclink pickup` is a subcommand. Top-level args include optional session_id, --ttl (default 86400), --qr. PickupArgs struct defined. main.rs dispatches correctly. Pickup is stubbed.</done>
</task>

<task type="auto">
  <name>Task 2: Implement the publish command end-to-end</name>
  <files>src/commands/publish.rs</files>
  <action>
Create `src/commands/publish.rs` implementing `run_publish(cli: &Cli) -> anyhow::Result<()>`.

**Full publish flow:**

1. **Load keypair and homeserver:**
   ```rust
   let keypair = crate::keys::store::load_keypair()?;
   let homeserver = crate::keys::store::read_homeserver()?;
   ```

2. **Discover or use explicit session (SESS-01 + SESS-02):**
   - If `cli.session_id` is `Some(id)`: use it directly. Set project to `std::env::current_dir()` display string.
   - If `cli.session_id` is `None`: call `crate::session::discover_sessions()?`
     - 0 sessions: bail with the `SessionNotFound` error (red)
     - 1 session: use it automatically
     - 2+ sessions: use `dialoguer::Select` to prompt user to pick one. Items show `"<session_id_first_8_chars> (<project>)"`. Default to index 0 (most recent). Guard with `std::io::stdin().is_terminal()` check — if not a TTY, use the first session without prompting.

3. **Display discovered session (colored):**
   ```rust
   use owo_colors::{OwoColorize, Stream::Stdout};
   println!("Session: {} in {}",
       session.session_id.if_supports_color(Stdout, |t| t.cyan()),
       session.project.if_supports_color(Stdout, |t| t.cyan()));
   ```

4. **Encrypt session ID (PUB-03 from Phase 2):**
   ```rust
   let x25519_secret = crate::crypto::ed25519_to_x25519_secret(&keypair);
   let x25519_pubkey = crate::crypto::ed25519_to_x25519_public(&keypair);
   let recipient = crate::crypto::age_recipient(&x25519_pubkey);
   let ciphertext = crate::crypto::age_encrypt(session.session_id.as_bytes(), &recipient)?;
   let blob = base64::engine::general_purpose::STANDARD.encode(&ciphertext);
   ```
   NOTE: `use base64::Engine;` must be in scope for the `.encode()` method.

5. **Build and sign record:**
   ```rust
   let created_at = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)?.as_secs();
   let hostname = gethostname::gethostname().to_string_lossy().into_owned();

   let signable = crate::record::HandoffRecordSignable {
       blob,
       created_at,
       hostname,
       project: session.project.clone(),
       pubkey: keypair.public_key().to_z32(),
       ttl: cli.ttl,
   };
   let signature = crate::record::sign_record(&signable, &keypair)?;
   let record = crate::record::HandoffRecord {
       blob: signable.blob,
       created_at: signable.created_at,
       hostname: signable.hostname,
       project: signable.project,
       pubkey: signable.pubkey,
       signature,
       ttl: signable.ttl,
   };
   ```

6. **Publish to homeserver (PUB-01):**
   ```rust
   let client = crate::transport::HomeserverClient::new(&homeserver)?;
   let token = client.publish(&keypair, &record)?;
   ```

7. **Output success (UX-01, PUB-04):**
   Print green "Published!" header. Print the copyable pickup command. Print TTL expiry in human terms.
   ```rust
   println!("\n{}", "Published!".if_supports_color(Stdout, |t| t.green().bold()));
   println!("  Run on another machine:");
   println!("  {}", format!("cclink pickup {}", token).if_supports_color(Stdout, |t| t.bold()));
   let hours = cli.ttl / 3600;
   println!("  Expires in {}h", hours);
   ```

8. **Optional QR code (PUB-06):**
   ```rust
   if cli.qr {
       println!();
       qr2term::print_qr(&format!("cclink pickup {}", token))
           .map_err(|e| anyhow::anyhow!("QR code render failed: {}", e))?;
   }
   ```

**Error handling:**
- No keypair: existing `CclinkError::NoKeypairFound` propagates
- No session: use `CclinkError::SessionNotFound`
- Network failure: let anyhow propagate the homeserver error with context
- All error messages should use red coloring via `eprintln!` with `Stream::Stderr`

Run `cargo check` to verify. Run `cargo test` to ensure no regressions.
  </action>
  <verify>`cargo check` succeeds; `cargo test` passes all existing tests; `cargo build` produces a binary where `cclink --help` shows the publish args and `cclink pickup --help` shows pickup args</verify>
  <done>Publish command implemented end-to-end: session discovery with multi-session picker, age encryption, record signing, homeserver publish, colored output with copyable pickup command and TTL expiry, optional QR code. All Phase 2 modules wired through publish flow.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes — CLI restructure and publish command compile
2. `cargo test` passes — no regressions in existing Phase 1/2 tests
3. `cclink --help` shows `[SESSION_ID]` optional positional, `--ttl`, `--qr`, and subcommands `init`, `whoami`, `pickup`
4. `cclink pickup --help` shows `[PUBKEY]` optional positional, `--yes/-y`, `--qr`
5. `src/commands/publish.rs` calls `session::discover_sessions()`, `crypto::age_encrypt()`, `record::sign_record()`, `transport::HomeserverClient::publish()`
6. Default TTL is 86400 (24 hours) not 28800 (8 hours)
7. Colored output uses `owo_colors::Stream::Stdout` for TTY-aware coloring
</verification>

<success_criteria>
The publish command is fully wired: `cclink` discovers a session, encrypts it, publishes to the homeserver, and prints a colored success message with the pickup command. The CLI supports `cclink <session-id>`, `cclink --ttl`, and `cclink --qr`.
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-commands/03-02-SUMMARY.md`
</output>
