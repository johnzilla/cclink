---
phase: 01-foundation-and-key-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/cli.rs
  - src/error.rs
  - src/keys/mod.rs
  - src/keys/store.rs
  - src/keys/fingerprint.rs
  - src/commands/mod.rs
  - src/commands/init.rs
autonomous: true
requirements:
  - KEY-01
  - KEY-03
  - KEY-04

must_haves:
  truths:
    - "User runs `cclink init` and a new Ed25519/PKARR keypair is generated and stored in ~/.pubky/secret_key with 0600 permissions"
    - "User runs `cclink init` a second time and is prompted to confirm overwrite, showing the existing key's fingerprint"
    - "User runs `cclink init --import /path/to/key` and the keypair is loaded from the file without loss"
    - "User runs `echo <hex> | cclink init --import -` and the keypair is loaded from stdin"
    - "If the user provides an invalid/corrupted key to import, the command fails with a clear error and nothing is written to disk"
    - "If the process is killed mid-write, the existing key file is not corrupted (atomic write verified)"
  artifacts:
    - path: "Cargo.toml"
      provides: "Rust project manifest with pkarr 5.0.3, clap 4.5, anyhow, thiserror, dirs dependencies"
      contains: "pkarr"
    - path: "src/main.rs"
      provides: "CLI entry point with clap parsing and subcommand dispatch"
      contains: "Cli::parse"
    - path: "src/cli.rs"
      provides: "Clap derive structs for CLI, Commands enum, InitArgs"
      exports: ["Cli", "Commands", "InitArgs"]
    - path: "src/error.rs"
      provides: "CclinkError thiserror enum with NoKeypairFound, InvalidKeyFormat variants"
      contains: "CclinkError"
    - path: "src/keys/store.rs"
      provides: "Key storage: path resolution, atomic write, load, overwrite guard"
      contains: "write_keypair_atomic"
    - path: "src/keys/fingerprint.rs"
      provides: "Short fingerprint formatting from public key z32"
      contains: "fingerprint"
    - path: "src/commands/init.rs"
      provides: "cclink init command: generate, import from file, import from stdin, overwrite prompt"
      contains: "run_init"
  key_links:
    - from: "src/commands/init.rs"
      to: "src/keys/store.rs"
      via: "write_keypair_atomic for all key persistence"
      pattern: "write_keypair_atomic"
    - from: "src/commands/init.rs"
      to: "pkarr::Keypair"
      via: "Keypair::random() for generation, from_secret_key_file for import"
      pattern: "Keypair::random|from_secret_key_file"
    - from: "src/keys/store.rs"
      to: "std::fs::rename"
      via: "Atomic write: write to temp then rename"
      pattern: "fs::rename"
    - from: "src/main.rs"
      to: "src/cli.rs"
      via: "Cli::parse() dispatches to command handlers"
      pattern: "Cli::parse"
---

<objective>
Scaffold the cclink Rust project and implement the `cclink init` command with keypair generation, import (file + stdin), atomic key storage, and overwrite protection.

Purpose: Establishes the project foundation and delivers the first working command. Everything in Phase 1 (and beyond) depends on the key store and CLI skeleton created here.
Output: A compilable Rust binary with `cclink init` that generates or imports a PKARR keypair and stores it atomically at `~/.pubky/secret_key`.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-key-management/01-RESEARCH.md
@.planning/phases/01-foundation-and-key-management/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Rust project with CLI skeleton, error types, and key store module</name>
  <files>
    Cargo.toml
    src/main.rs
    src/cli.rs
    src/error.rs
    src/keys/mod.rs
    src/keys/store.rs
    src/keys/fingerprint.rs
    src/commands/mod.rs
  </files>
  <action>
Create the Rust project structure for cclink.

**Cargo.toml:**
- Package name: `cclink`, version `0.1.0`, edition `2021`
- `[[bin]]` section: name `cclink`, path `src/main.rs`
- Dependencies: `pkarr = { version = "5.0.3", default-features = false }`, `clap = { version = "4.5", features = ["derive"] }`, `anyhow = "1.0"`, `thiserror = "2.0"`, `dirs = "5"`
- NOTE: Do NOT add `arboard` yet (that's Plan 02 for whoami)
- If `pkarr` with `default-features = false` fails to compile (Keypair not available), add features back incrementally

**src/cli.rs** — Clap derive structs:
- `Cli` struct with `#[derive(Parser)]`, `#[command(name = "cclink", version, about = "Secure session handoff via Pubky")]`
- `Commands` enum with `#[derive(Subcommand)]`: `Init(InitArgs)`, `Whoami` (Whoami variant exists but handler will be added in Plan 02)
- `InitArgs` struct: `--import` (Option<String>, value_name "PATH"), `--homeserver` (String, default "https://pubky.app"), `--yes` or `-y` (bool flag, skip overwrite confirmation)

**src/error.rs** — Domain errors using thiserror:
- `CclinkError` enum with variants:
  - `NoKeypairFound` — "No keypair found. Run `cclink init` first."
  - `InvalidKeyFormat(String)` — "Invalid key format: {0}"
  - `KeyCorrupted(String)` — "Key file corrupted: {0}"
  - `AtomicWriteFailed(#[source] std::io::Error)` — "Failed to write key file atomically"
  - `HomeDirNotFound` — "Cannot determine home directory"

**src/keys/store.rs** — Key storage operations:
- `key_dir() -> anyhow::Result<PathBuf>`: Returns `~/.pubky/` using `dirs::home_dir()`
- `secret_key_path() -> anyhow::Result<PathBuf>`: Returns `key_dir()?.join("secret_key")`
- `homeserver_path() -> anyhow::Result<PathBuf>`: Returns `key_dir()?.join("cclink_homeserver")` (stores homeserver URL as plain text)
- `ensure_key_dir() -> anyhow::Result<()>`: Calls `std::fs::create_dir_all(key_dir()?)` — prevents "No such file or directory" error on first run
- `write_keypair_atomic(keypair: &pkarr::Keypair, dest: &Path) -> anyhow::Result<()>`: Write to temp file in SAME directory (`parent/.secret_key.tmp`), call `keypair.write_secret_key_file(&tmp)`, then `std::fs::rename(&tmp, dest)`. If rename fails, attempt cleanup of temp file. This is the ONLY way to write keys — never call `write_secret_key_file` directly on the destination.
- `write_homeserver(homeserver: &str) -> anyhow::Result<()>`: Write homeserver URL to `~/.pubky/cclink_homeserver` (plain text, no atomic write needed — it's not a secret)
- `read_homeserver() -> anyhow::Result<String>`: Read homeserver URL from file, return default "https://pubky.app" if file doesn't exist
- `load_keypair() -> anyhow::Result<pkarr::Keypair>`: Check if `secret_key_path()` exists; if not, return `Err(CclinkError::NoKeypairFound)`; otherwise call `Keypair::from_secret_key_file(path)` with context
- `keypair_exists() -> anyhow::Result<bool>`: Check if secret key file exists at expected path

**src/keys/fingerprint.rs:**
- `short_fingerprint(public_key: &pkarr::PublicKey) -> String`: Return first 8 characters of `public_key.to_z32()`

**src/keys/mod.rs:** Re-export `store` and `fingerprint` modules
**src/commands/mod.rs:** Declare `pub mod init;` (and `pub mod whoami;` placeholder)

**src/main.rs:**
- Parse CLI with `Cli::parse()`
- Match on `Commands::Init(args)` -> call `commands::init::run_init(args)?`
- Match on `Commands::Whoami` -> print "Not yet implemented" (Plan 02 adds this)
- Use `anyhow::Result<()>` as main return type
- Module declarations: `mod cli; mod error; mod keys; mod commands;`

After creating all files, run `cargo check` to verify the project compiles. If pkarr with `default-features = false` fails, adjust features. Fix any compilation errors before proceeding.
  </action>
  <verify>
    `cargo check` succeeds with no errors. `cargo build` produces a binary. Running `./target/debug/cclink --help` shows the CLI help with `init` and `whoami` subcommands. Running `./target/debug/cclink init --help` shows `--import`, `--homeserver`, and `--yes` flags.
  </verify>
  <done>
    The cclink binary compiles, CLI argument parsing works for all subcommands and flags, key store module has all path resolution and atomic write functions, error types are defined. The project is ready for command implementation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cclink init — generate keypair, atomic write, overwrite guard, import from file and stdin</name>
  <files>
    src/commands/init.rs
  </files>
  <action>
Implement the full `cclink init` command in `src/commands/init.rs`.

**Core flow — `run_init(args: InitArgs) -> anyhow::Result<()>`:**

1. Call `keys::store::ensure_key_dir()` to create `~/.pubky/` if needed
2. Get `secret_key_path()`
3. **Overwrite guard:** If `keypair_exists()?` is true AND `--yes` flag is not set:
   - Load existing keypair with `Keypair::from_secret_key_file`
   - Get fingerprint via `keys::fingerprint::short_fingerprint`
   - Print to stderr: `"Key {fingerprint} already exists at {path}. Overwrite? [y/N]: "`
   - Flush stderr, read line from stdin
   - If response is not "y" or "Y", print "Aborted." and return Ok(())
   - If loading the existing key fails (corrupted), show "(unreadable)" as the fingerprint identifier
4. **Generate or Import:**
   - If `args.import` is `None` → generate: `let keypair = Keypair::random();`
   - If `args.import` is `Some(path)` where path is `"-"` → import from stdin:
     - Read all of stdin to string, trim whitespace
     - The hex string should be 64 characters (32 bytes hex-encoded) — validate length
     - Write the trimmed hex to a temp file in `~/.pubky/`, then use `Keypair::from_secret_key_file(&tmp_path)` to load and validate (this avoids the `from_secret_key` type ambiguity — see Research open question #1)
     - Clean up the temp file after loading
     - If loading fails, return error "Invalid key data from stdin" — do NOT write anything to the real destination
   - If `args.import` is `Some(path)` where path is not `"-"` → import from file:
     - Call `Keypair::from_secret_key_file(Path::new(&path))` to load and validate
     - If loading fails, return error "Invalid key file at {path}: {error}" — do NOT write to destination
5. **Write atomically:** Call `keys::store::write_keypair_atomic(&keypair, &secret_key_path)`
6. **Write homeserver:** Call `keys::store::write_homeserver(&args.homeserver)`
7. **Success output** (per locked decisions):
   - For generate: "Keypair generated successfully."
   - For import: "Keypair imported successfully."
   - Then blank line, then:
   - `"Public Key:  {keypair.public_key().to_uri_string()}"`
   - `"Homeserver:  {args.homeserver}"`
   - `"Key file:    {secret_key_path.display()}"`
   - Blank line
   - `"Next: run 'cclink' to publish your first session handoff."`

**Edge cases to handle:**
- `ensure_key_dir` failure (permissions) → bubble up with context "Failed to create ~/.pubky/ directory"
- Stdin import with empty input → clear error "No key data received from stdin"
- Stdin import with non-hex characters → clear error "Invalid hex format — expected 64 hex characters"
- File import with nonexistent file → clear error from `from_secret_key_file` with added context
- Overwrite prompt when stdin is piped (not a terminal) → respect `--yes` flag; if stdin is not a terminal and `--yes` not set, default to abort with message "Use --yes to confirm overwrite in non-interactive mode"
  </action>
  <verify>
    Build with `cargo build`. Then test manually:
    1. `./target/debug/cclink init` — generates keypair, shows public key, homeserver, key file path
    2. Verify `~/.pubky/secret_key` exists with `ls -la ~/.pubky/secret_key` — should show 0600 permissions
    3. Verify `~/.pubky/cclink_homeserver` contains "https://pubky.app"
    4. `./target/debug/cclink init` again (without --yes) — should prompt for overwrite, showing fingerprint
    5. `./target/debug/cclink init --yes` — should overwrite without prompt
    6. `./target/debug/cclink init --homeserver https://custom.server` — should store custom homeserver
    7. Export existing key: `cat ~/.pubky/secret_key | ./target/debug/cclink init --import - --yes` — should import from stdin
    8. `./target/debug/cclink init --import ~/.pubky/secret_key --yes` — should import from file
    9. `echo "invalid" | ./target/debug/cclink init --import - --yes` — should fail with clear error
    10. `./target/debug/cclink init --import /nonexistent --yes` — should fail with clear error
  </verify>
  <done>
    `cclink init` generates a keypair and stores it atomically at `~/.pubky/secret_key` with 0600 permissions. Import from file and stdin both work, validating key data before writing. Overwrite prompt shows existing key fingerprint. Invalid keys produce clear errors without writing to disk. Homeserver is persisted to `~/.pubky/cclink_homeserver`.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `cclink init` creates `~/.pubky/secret_key` with 0600 permissions
3. `cclink init` a second time prompts for overwrite with fingerprint displayed
4. `cclink init --import <file>` loads an existing key correctly (round-trip: init, copy secret_key, delete, import copy, whoami shows same public key)
5. `echo <hex> | cclink init --import -` loads from stdin
6. Invalid key input (bad hex, wrong length, nonexistent file) fails with clear error, no file written
7. `~/.pubky/cclink_homeserver` contains the homeserver URL
</verification>

<success_criteria>
- The cclink binary compiles and runs
- `cclink init` generates and atomically stores a PKARR keypair
- `cclink init --import` works from both file path and stdin
- Overwrite protection prompts with existing key fingerprint
- All error paths produce clear user-facing messages
- No key data is written to disk until validation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-key-management/01-01-SUMMARY.md`
</output>
