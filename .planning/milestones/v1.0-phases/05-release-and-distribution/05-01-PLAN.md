---
phase: 05-release-and-distribution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - tests/integration_round_trip.rs
  - tests/plaintext_leak.rs
autonomous: true
requirements: []

must_haves:
  truths:
    - "Self-encrypt round-trip test passes: encrypt session ID to own key, decrypt, compare"
    - "Shared-encrypt round-trip test passes: encrypt to recipient key, decrypt with recipient identity, compare"
    - "Burn-after-read round-trip test passes: encrypt with burn flag, decrypt, compare"
    - "Shared+burn round-trip test passes: encrypt to recipient with burn, decrypt, compare"
    - "Plaintext leak test passes: encrypted blob does not contain the known session ID string in any form"
    - "All integration tests run without network access or external dependencies"
  artifacts:
    - path: "Cargo.toml"
      provides: "httpmock dev-dependency"
      contains: "httpmock"
    - path: "tests/integration_round_trip.rs"
      provides: "Round-trip encryption integration tests for all 4 code paths"
      min_lines: 80
    - path: "tests/plaintext_leak.rs"
      provides: "Plaintext leak detection test"
      min_lines: 20
  key_links:
    - from: "tests/integration_round_trip.rs"
      to: "src/crypto/mod.rs"
      via: "use cclink::crypto::*"
      pattern: "age_encrypt|age_decrypt|age_identity|age_recipient|recipient_from_z32"
    - from: "tests/plaintext_leak.rs"
      to: "src/crypto/mod.rs"
      via: "use cclink::crypto::*"
      pattern: "age_encrypt|age_recipient"
---

<objective>
Add integration tests that verify every encryption code path round-trips correctly and that encrypted blobs never leak plaintext.

Purpose: CI must prove that self-encrypt, shared-encrypt, burn, and shared+burn all produce decryptable output. A dedicated plaintext leak test ensures session IDs are never visible in ciphertext.

Output: `tests/integration_round_trip.rs`, `tests/plaintext_leak.rs`, httpmock dev-dependency in Cargo.toml
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-release-and-distribution/05-RESEARCH.md
@src/crypto/mod.rs
@src/record/mod.rs
@src/transport/mod.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add httpmock dev-dependency and create round-trip encryption integration tests</name>
  <files>Cargo.toml, tests/integration_round_trip.rs</files>
  <action>
1. Add `httpmock = "0.8"` under `[dev-dependencies]` in Cargo.toml. Create the `[dev-dependencies]` section if it does not exist.

2. Create `tests/integration_round_trip.rs` with four integration tests covering every encryption code path. The tests must be `#[test]` functions (NOT `#[tokio::test]`).

   Make the crypto module's functions accessible from integration tests. The crate must expose its modules publicly. Check `src/main.rs` or `src/lib.rs` — if there is no `src/lib.rs`, create one that re-exports `pub mod crypto;`, `pub mod record;`, and `pub mod transport;` (and any other modules needed). If a `lib.rs` already exists, ensure the required modules are `pub`.

   **Test 1: `test_self_encrypt_round_trip`**
   - Create a fixed keypair via `pkarr::Keypair::from_secret_key(&[42u8; 32])`
   - Derive X25519 secret and public via `ed25519_to_x25519_secret` and `ed25519_to_x25519_public`
   - Build age identity and recipient
   - Encrypt a known session ID string (e.g., `"sess-abc123-round-trip-test"`) using `age_encrypt`
   - Decrypt with `age_decrypt` using the identity
   - Assert decrypted bytes == original session ID bytes

   **Test 2: `test_shared_encrypt_round_trip`**
   - Create two fixed keypairs (sender seed `[42u8; 32]`, recipient seed `[99u8; 32]`)
   - Derive recipient's X25519 public key, build age Recipient
   - Encrypt a session ID to the recipient's key
   - Derive recipient's X25519 secret, build age Identity
   - Decrypt with recipient's identity
   - Assert decrypted bytes == original session ID bytes
   - Also verify sender CANNOT decrypt: derive sender identity, call `age_decrypt`, assert `is_err()`

   **Test 3: `test_burn_encrypt_round_trip`**
   - Same as self-encrypt but conceptually confirms burn flag doesn't affect crypto
   - Create keypair, encrypt session ID to own key, decrypt, compare
   - The burn flag is a metadata field on HandoffRecord, not a crypto concern — this test confirms the encryption path is identical whether burn is true or false

   **Test 4: `test_shared_burn_encrypt_round_trip`**
   - Combine shared + burn: encrypt to recipient key
   - Decrypt with recipient identity
   - Assert decrypted == original
   - Assert sender cannot decrypt

   All tests should use `use cclink::crypto::*;` (or individual function imports).
  </action>
  <verify>`cargo test --test integration_round_trip` passes with 4 tests OK and 0 failures</verify>
  <done>Four integration tests pass, covering self-encrypt, shared-encrypt, burn, and shared+burn round-trip decryption</done>
</task>

<task type="auto">
  <name>Task 2: Create plaintext leak detection test</name>
  <files>tests/plaintext_leak.rs</files>
  <action>
Create `tests/plaintext_leak.rs` with tests that verify encrypted blobs never contain plaintext session data.

**Test 1: `test_encrypted_blob_contains_no_plaintext_session_id`**
- Create a fixed keypair
- Define a known session ID: `"KNOWN-SESSION-ID-abc123-MUST-NOT-APPEAR"`
- Encrypt the session ID using `age_encrypt` to own recipient key
- Convert the ciphertext to a lossy UTF-8 string
- Assert the known session ID string is NOT present in the ciphertext string
- Also do a byte window scan: `ciphertext.windows(known_id.len()).any(|w| w == known_id.as_bytes())` — assert this is false

**Test 2: `test_shared_encrypted_blob_contains_no_plaintext`**
- Same as above but encrypt to a different recipient's key (seed `[99u8; 32]`)
- Same assertions: no plaintext in ciphertext bytes

**Test 3: `test_base64_encoded_blob_contains_no_plaintext`**
- Encrypt a session ID, then base64-encode the ciphertext (as the publish path does)
- Assert the base64-encoded string does not contain the plaintext session ID
- This tests what actually gets stored in the HandoffRecord blob field

Use `use cclink::crypto::{age_encrypt, age_recipient, ed25519_to_x25519_public};` and `use base64::Engine;` for the base64 test.
  </action>
  <verify>`cargo test --test plaintext_leak` passes with 3 tests OK and 0 failures</verify>
  <done>Three plaintext leak tests pass, proving encrypted blobs never expose session ID strings in raw bytes or base64 form</done>
</task>

</tasks>

<verification>
1. `cargo test --test integration_round_trip` — 4 tests pass
2. `cargo test --test plaintext_leak` — 3 tests pass
3. `cargo test` — all existing tests + new integration tests pass (no regressions)
4. No `#[ignore]` or `#[tokio::test]` markers on integration tests — all run in standard `#[test]`
</verification>

<success_criteria>
- 7 new integration tests pass covering all 4 encryption code paths plus plaintext leak detection
- httpmock dev-dependency present in Cargo.toml (used by Plan 02 for HTTP-level integration tests if needed later; present now for consistency with research recommendations)
- No regressions in existing unit tests
</success_criteria>

<output>
After completion, create `.planning/phases/05-release-and-distribution/05-01-SUMMARY.md`
</output>
