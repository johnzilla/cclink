---
phase: 02-crypto-and-transport
plan: 03
type: auto
wave: 3
depends_on:
  - 02-01
  - 02-02
files_modified:
  - src/transport/mod.rs
  - src/main.rs
autonomous: true
requirements:
  - PUB-05
  - UX-02

must_haves:
  truths:
    - "An AuthToken can be built and serialized to binary with a valid Ed25519 signature over the signable region"
    - "HomeserverClient constructs correct URLs following /pub/cclink/<token> and /pub/cclink/latest patterns"
    - "HomeserverClient is configured with cookie_store(true) for session persistence"
    - "publish() generates a timestamp-based token and constructs both record and latest pointer payloads"
    - "Retrieved records have their Ed25519 signature verified before bytes are returned to the caller"
    - "(#[ignore] integration) signin + PUT + GET round-trips against a live homeserver"
  artifacts:
    - path: "src/transport/mod.rs"
      provides: "AuthToken builder, homeserver client with signin/put/get, latest.json writes"
      exports: ["build_auth_token", "HomeserverClient", "get_record", "get_record_by_pubkey", "publish"]
  key_links:
    - from: "src/transport/mod.rs"
      to: "reqwest::blocking::Client"
      via: "cookie_store(true) for session persistence across PUT calls"
      pattern: "cookie_store.*true"
    - from: "src/transport/mod.rs"
      to: "postcard"
      via: "postcard::to_allocvec for AuthToken binary serialization"
      pattern: "postcard::to_allocvec"
    - from: "src/transport/mod.rs"
      to: "src/record/mod.rs"
      via: "PUT serialized HandoffRecord bytes, GET deserializes and calls verify_record before returning"
      pattern: "verify_record"
---

<objective>
Implement the transport module with Pubky homeserver authentication, record PUT/GET, and latest.json pointer updates.

Purpose: PUB-05 requires a latest.json pointer updated on each publish. The transport module is the HTTP layer that connects the crypto and record modules to the Pubky homeserver, enabling Phase 3's publish/pickup commands.
Output: Working `src/transport/mod.rs` with AuthToken construction, homeserver signin, and PUT/GET operations.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-crypto-and-transport/02-RESEARCH.md
@.planning/phases/02-crypto-and-transport/02-01-SUMMARY.md
@.planning/phases/02-crypto-and-transport/02-02-SUMMARY.md
@src/keys/store.rs
@src/record/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AuthToken builder with empirical byte layout verification</name>
  <files>src/transport/mod.rs, src/main.rs</files>
  <action>
Add `mod transport;` to `src/main.rs`.

Create `src/transport/mod.rs`. The AuthToken is the hardest part of this module -- the homeserver only accepts postcard-serialized binary tokens. The research identified an open question about the signable byte offset (65 vs 64).

**Step 1: Empirical verification.** Write a `#[cfg(test)]` test that:
- Adds `pubky-common = "0.5.4"` as a `[dev-dependencies]` in Cargo.toml (it's in the cargo registry)
- If pubky-common 0.5.4 is NOT compatible with the project's pkarr 5.0.3 (likely -- pubky-common may depend on older pkarr), then SKIP this approach and implement from the research notes directly, documenting the assumed layout
- If it IS compatible: create an AuthToken using pubky-common's API, serialize it with postcard, and print the byte layout to determine the exact signable offset

**Step 2: Implement AuthToken builder.** Based on the empirical result (or research notes if empirical fails):

```rust
pub fn build_auth_token(keypair: &pkarr::Keypair) -> anyhow::Result<Vec<u8>>
```

The AuthToken binary layout from research (postcard serialized):
- Bytes [0..64]: Ed25519 signature (64 raw bytes)
- Byte 64+: signable region starts (namespace "PUBKY:AUTH" + version + timestamp + pubkey + capabilities)
- The signature covers the signable region (everything after the signature bytes)

Implementation approach:
1. Build the signable payload first:
   - Namespace: `b"PUBKY:AUTH"` (10 bytes, but postcard may add length prefix for [u8; 10] or tuple)
   - Version: `0u8`
   - Timestamp: current Unix timestamp as `u64` (postcard encodes u64 as varint)
   - Pubkey: `[u8; 32]` from `keypair.public_key().to_bytes()`
   - Capabilities: `"/:rw"` as a String (postcard encodes as varint length + UTF-8 bytes)
2. Serialize the signable payload with postcard
3. Sign the signable bytes with `keypair.sign(&signable_bytes)`
4. Concatenate: `[signature_bytes (64)] + [signable_bytes]`
5. This concatenated form is what the homeserver expects

**IMPORTANT:** The exact serialization format needs to match what `pubky-common` produces. If the empirical test works, match it exactly. If not, implement from the struct definition in pubky-common source:

```rust
// From pubky-common-0.5.4/src/auth.rs:
// AuthToken { signature: Signature, pubkey: PublicKey, timestamp: Timestamp, capabilities: Vec<Capability> }
// The `signable` method returns bytes[65..] of the serialized token
```

The safest approach: define a `#[derive(Serialize)]` struct matching pubky-common's `AuthToken` field order, serialize with `postcard::to_allocvec`, and compute signature over the bytes after the first 64 (or 65 per research).

Write tests:
1. `test_auth_token_has_valid_length` -- token is at least 64 + 10 + 1 + 1 + 32 + 5 = ~113 bytes
2. `test_auth_token_starts_with_64_byte_signature` -- first 64 bytes are a valid Ed25519 signature over the remaining bytes (verify with the keypair's public key)
3. `test_auth_token_deterministic_minus_timestamp` -- two tokens built 0 seconds apart with same keypair differ only in timestamp and signature

NOTE: If the empirical test reveals the offset is 65 (not 64), adjust accordingly. The test in step 2 (`first 64 bytes are signature over remaining bytes`) will confirm the correct offset by trying both 64 and 65.
  </action>
  <verify>`cargo test --lib transport::tests::test_auth_token` -- AuthToken tests pass. Signature over signable region verifies.</verify>
  <done>AuthToken binary serialization matches the format expected by Pubky homeserver, with empirically verified byte layout</done>
</task>

<task type="auto">
  <name>Task 2: Implement HomeserverClient with signin, PUT record, GET record, and latest.json pointer</name>
  <files>src/transport/mod.rs</files>
  <action>
Implement a `HomeserverClient` struct wrapping `reqwest::blocking::Client`:

```rust
pub struct HomeserverClient {
    client: reqwest::blocking::Client,
    homeserver: String,  // e.g. "pubky.app"
}
```

**Constructor:**
```rust
pub fn new(homeserver: &str) -> anyhow::Result<Self>
```
- Build `reqwest::blocking::Client::builder().cookie_store(true).timeout(Duration::from_secs(30)).build()?`
- Store homeserver hostname (strip `https://` prefix if present)

**Signin:**
```rust
pub fn signin(&self, keypair: &pkarr::Keypair) -> anyhow::Result<()>
```
- Call `build_auth_token(keypair)?` to get the binary token
- POST to `https://{homeserver}/session` with body = token bytes
- Check response status is 2xx
- Session cookie is automatically stored in the client's cookie jar
- On non-2xx: return error with status code and response body for debugging

**PUT record:**
```rust
pub fn put_record(&self, token: &str, record_json: &[u8]) -> anyhow::Result<()>
```
- PUT to `https://{homeserver}/pub/cclink/{token}`
- Content-Type: `application/octet-stream`
- Body: record_json bytes
- Check response status is 2xx
- On 404: may indicate wrong URL routing -- see research pitfall 4. Try with `pubky-host` header set to the user's z32 public key if first attempt fails.

**PUT latest pointer:**
```rust
pub fn put_latest(&self, latest_json: &[u8]) -> anyhow::Result<()>
```
- PUT to `https://{homeserver}/pub/cclink/latest`
- Content-Type: `application/octet-stream`
- Body: latest_json bytes (serialized LatestPointer from record module)

**GET record (with signature verification):**
```rust
pub fn get_record(&self, token: &str, pubkey: &pkarr::PublicKey) -> anyhow::Result<HandoffRecord>
```
- GET from `https://{homeserver}/pub/cclink/{token}`
- No auth needed for GET (public data)
- On 404: return a clear "Record not found" error
- Deserialize response bytes to `HandoffRecord` via `serde_json::from_slice`
- Call `verify_record(&record, pubkey)` (from `crate::record`) -- if verification fails, return error (hard fail per user decision)
- Return verified `HandoffRecord` only if signature passes

**GET record by pubkey (with signature verification):**
```rust
pub fn get_record_by_pubkey(&self, pubkey_z32: &str, token: &str, pubkey: &pkarr::PublicKey) -> anyhow::Result<HandoffRecord>
```
- GET from `https://{homeserver}/{pubkey_z32}/pub/cclink/{token}`
- This is the multi-tenant URL pattern for reading another user's records
- Alternatively, try with `pubky-host: {pubkey_z32}` header if the path-based approach returns 404
- Deserialize response bytes to `HandoffRecord` via `serde_json::from_slice`
- Call `verify_record(&record, pubkey)` -- if verification fails, return error (hard fail)
- Return verified `HandoffRecord` only if signature passes

**GET latest pointer:**
```rust
pub fn get_latest(&self, pubkey_z32: Option<&str>) -> anyhow::Result<Vec<u8>>
```
- If pubkey_z32 is None: GET `https://{homeserver}/pub/cclink/latest` (own records, needs session)
- If pubkey_z32 is Some: GET `https://{homeserver}/{pubkey_z32}/pub/cclink/latest` (other user's records)

**Convenience method: publish (PUT record + latest in one call):**
```rust
pub fn publish(&self, keypair: &pkarr::Keypair, record: &HandoffRecord) -> anyhow::Result<String>
```
- Generate token from `record.created_at` (Unix timestamp as string -- per user decision, tokens are timestamp-based)
- Serialize record to JSON bytes: `serde_json::to_vec(record)?`
- Call `self.signin(keypair)?`
- Call `self.put_record(&token, &record_bytes)?`
- Build LatestPointer from record (token, project, hostname, created_at)
- Serialize latest pointer: `serde_json::to_vec(&latest)?`
- Call `self.put_latest(&latest_bytes)?`
- Return the token string

Write tests:
1. `test_homeserver_client_new` -- client builds successfully with cookie_store enabled
2. `test_publish_constructs_correct_token` -- token is the created_at timestamp as string
3. `test_get_record_verifies_signature` -- construct a signed HandoffRecord JSON, mock/simulate the deserialization + verify_record call, confirm that a valid record passes and a tampered record fails. This can be tested without a live homeserver by directly testing the deserialization + verification pipeline: serialize a signed record to JSON bytes, then call the same deserialization + verify_record logic that get_record uses internally.

NOTE: Full integration tests against a live homeserver are NOT expected in this plan. The transport module is designed so that Phase 3 can integration-test the full publish/pickup flow. Unit tests here focus on correct URL construction, token generation, AuthToken validity, and signature verification on retrieved records. If a local pubky homeserver is available for testing, add an `#[ignore]` integration test that does a full signin + PUT + GET round-trip.
  </action>
  <verify>`cargo test --lib transport` -- all transport tests pass. `cargo check` clean.</verify>
  <done>HomeserverClient can construct correct URLs, build valid AuthTokens, and exposes signin/put/get/publish methods ready for Phase 3 integration. GET methods deserialize and verify Ed25519 signatures before returning records to the caller.</done>
</task>

</tasks>

<verification>
1. `cargo test --lib transport` -- all transport tests pass
2. `cargo check` -- entire project compiles clean
3. `cargo test` -- ALL tests across all modules pass (crypto + record + transport)
4. AuthToken signature verifies against the signable region (empirically confirmed offset)
</verification>

<success_criteria>
- AuthToken binary format produces tokens with valid Ed25519 signatures over the signable region
- HomeserverClient builds with cookie_store enabled
- URL construction follows the `/pub/cclink/<token>` and `/pub/cclink/latest` patterns per user decisions
- publish() generates timestamp-based tokens and writes both record and latest pointer
- All three modules (crypto, record, transport) compile and test together
</success_criteria>

<output>
After completion, create `.planning/phases/02-crypto-and-transport/02-03-SUMMARY.md`
</output>
