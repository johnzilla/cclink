---
phase: 04-advanced-encryption-and-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/record/mod.rs
  - src/crypto/mod.rs
  - src/transport/mod.rs
  - src/cli.rs
  - src/commands/mod.rs
  - src/error.rs
autonomous: true
requirements:
  - ENC-01
  - ENC-02
  - MGT-01
  - MGT-02
  - MGT-03

must_haves:
  truths:
    - "HandoffRecord can serialize and deserialize with burn and recipient fields, defaulting gracefully for Phase 3 records"
    - "A z32 pubkey string can be converted to an age X25519 Recipient for encryption"
    - "HomeserverClient can DELETE a record and LIST all record tokens"
    - "CLI accepts --share, --burn flags and List, Revoke subcommands"
  artifacts:
    - path: "src/record/mod.rs"
      provides: "HandoffRecord with burn and recipient fields using serde defaults"
      contains: "pub burn"
    - path: "src/crypto/mod.rs"
      provides: "recipient_from_z32 helper"
      exports: ["recipient_from_z32"]
    - path: "src/transport/mod.rs"
      provides: "delete_record and list_record_tokens methods"
      contains: "fn delete_record"
    - path: "src/cli.rs"
      provides: "CLI with --share, --burn, List, Revoke subcommands"
      contains: "Revoke"
  key_links:
    - from: "src/crypto/mod.rs"
      to: "pkarr::PublicKey"
      via: "recipient_from_z32 parses z32 and derives X25519"
      pattern: "PublicKey::try_from"
    - from: "src/transport/mod.rs"
      to: "homeserver DELETE endpoint"
      via: "delete_record sends HTTP DELETE"
      pattern: "client\\.delete"
---

<objective>
Extend the foundational modules (record, crypto, transport, CLI) with all the primitives Phase 4 commands need: new HandoffRecord fields, z32-to-recipient conversion, homeserver DELETE/LIST methods, and CLI argument definitions.

Purpose: Every Phase 4 feature (--share, --burn, list, revoke) depends on these extensions. Building them first avoids modifying shared modules from multiple parallel plans.

Output: Extended record/crypto/transport/CLI modules with all Phase 4 primitives. New comfy-table dependency added.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-encryption-and-management/04-RESEARCH.md
@.planning/phases/02-crypto-and-transport/02-01-SUMMARY.md
@.planning/phases/02-crypto-and-transport/02-02-SUMMARY.md
@.planning/phases/02-crypto-and-transport/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add comfy-table dep and extend HandoffRecord with burn/recipient fields</name>
  <files>Cargo.toml, src/record/mod.rs</files>
  <action>
1. Add comfy-table dependency: `cargo add comfy-table@7.2.2`

2. Extend `HandoffRecord` in `src/record/mod.rs` with two new fields in ALPHABETICAL order:
   - `burn: bool` with `#[serde(default)]` — placed between `blob` and `created_at`
   - `recipient: Option<String>` with `#[serde(default)]` — placed between `pubkey` and `signature`

   Result ordering: blob, burn, created_at, hostname, project, pubkey, recipient, signature, ttl

3. CRITICAL DECISION: Do NOT add `burn` or `recipient` to `HandoffRecordSignable`. These fields are unsigned metadata. Rationale: Phase 3 records were signed without these fields. If we add them to the signable struct, `#[serde(default)]` will inject `burn: false` and `recipient: null` during deserialization, changing the canonical JSON and breaking signature verification of all existing Phase 3 records. Keeping them unsigned is pragmatic for a single-user tool where the user controls their own homeserver records.

4. Update the `From<&HandoffRecord> for HandoffRecordSignable` impl — it already copies all fields except `signature`. Since we are NOT adding burn/recipient to HandoffRecordSignable, no change is needed to this impl. However, verify that the existing impl still compiles (it only accesses blob, created_at, hostname, project, pubkey, ttl — none of which changed).

5. Update test helpers that construct HandoffRecord directly (e.g., `test_sign_and_verify_round_trip`, `test_verify_fails_wrong_pubkey`, `test_verify_fails_tampered_json`). Add the new fields with defaults:
   - `burn: false`
   - `recipient: None`

   This ensures existing tests still compile and pass.

6. Add a new test `test_phase3_record_backwards_compat`:
   - Create a JSON string WITHOUT burn/recipient fields (simulating a Phase 3 record)
   - Deserialize it to HandoffRecord
   - Assert burn == false and recipient == None
   - Sign it with a keypair, then verify — should pass (signable struct unchanged)

7. Verify: `cargo test -- record` passes all existing + new tests.
  </action>
  <verify>
    `cargo test -- record` passes. Existing 7 tests still pass. New backwards-compat test passes.
  </verify>
  <done>
    HandoffRecord has burn and recipient fields with serde defaults. Phase 3 records deserialize correctly and pass signature verification. comfy-table 7.2.2 is in Cargo.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add recipient_from_z32 to crypto and extend transport with delete/list</name>
  <files>src/crypto/mod.rs, src/transport/mod.rs</files>
  <action>
1. Add `recipient_from_z32` to `src/crypto/mod.rs`:
   ```rust
   pub fn recipient_from_z32(z32: &str) -> anyhow::Result<age::x25519::Recipient> {
       let pubkey = pkarr::PublicKey::try_from(z32)
           .map_err(|e| anyhow::anyhow!("invalid recipient pubkey '{}': {}", z32, e))?;
       let x25519_bytes: [u8; 32] = pubkey.verifying_key().to_montgomery().to_bytes();
       Ok(age_recipient(&x25519_bytes))
   }
   ```
   This uses the exact same conversion path as `ed25519_to_x25519_public()` but starts from a parsed PublicKey instead of a Keypair.

2. Add test `test_recipient_from_z32_round_trip` to crypto tests:
   - Create a keypair, get its z32 pubkey via `keypair.public_key().to_z32()`
   - Call `recipient_from_z32(&z32)` — should succeed
   - Encrypt a plaintext to this recipient
   - Decrypt with the keypair's identity — should succeed (proves the recipient is correct)

3. Add test `test_recipient_from_z32_invalid_key`:
   - Call `recipient_from_z32("not-a-valid-z32-key")` — should return Err

4. Add `delete_record` method to `HomeserverClient` in `src/transport/mod.rs`:
   ```rust
   pub fn delete_record(&self, token: &str) -> anyhow::Result<()> {
       let url = format!("https://{}/pub/cclink/{}", self.homeserver, token);
       let response = self.client.delete(&url).send()
           .map_err(|e| anyhow::anyhow!("DELETE request failed: {}", e))?;
       if response.status() == reqwest::StatusCode::NOT_FOUND {
           return Ok(()); // Already deleted — idempotent
       }
       if !response.status().is_success() {
           let status = response.status();
           anyhow::bail!("DELETE failed (status {}): {}", status, token);
       }
       Ok(())
   }
   ```
   Must be called AFTER signin() — the cookie_store forwards the session cookie.

5. Add `list_record_tokens` method to `HomeserverClient`:
   ```rust
   pub fn list_record_tokens(&self) -> anyhow::Result<Vec<String>> {
       let url = format!("https://{}/pub/cclink/", self.homeserver);
       let response = self.client.get(&url).send()
           .map_err(|e| anyhow::anyhow!("LIST request failed: {}", e))?;
       if response.status() == reqwest::StatusCode::NOT_FOUND {
           return Ok(vec![]);
       }
       if !response.status().is_success() {
           anyhow::bail!("LIST failed (status {})", response.status());
       }
       let body = response.text()
           .map_err(|e| anyhow::anyhow!("failed to read LIST response: {}", e))?;
       let tokens: Vec<String> = body.lines()
           .filter(|l| !l.is_empty())
           .filter_map(|line| {
               line.split("/pub/cclink/").nth(1)
                   .map(|t| t.trim_end_matches('/').to_string())
           })
           .filter(|t| t.parse::<u64>().is_ok()) // Filter out "latest" and non-numeric keys
           .collect();
       Ok(tokens)
   }
   ```
   CRITICAL: Filter out "latest" key — it is a LatestPointer, not a HandoffRecord. Use `t.parse::<u64>().is_ok()` to keep only numeric timestamp tokens.

6. Update HandoffRecord construction in transport tests to include the new burn/recipient fields (burn: false, recipient: None).

7. Verify: `cargo test -- crypto` and `cargo test -- transport` pass.
  </action>
  <verify>
    `cargo test -- crypto` passes (existing 5 + 2 new tests). `cargo test -- transport` passes (existing 9 + integration test still ignored).
  </verify>
  <done>
    `recipient_from_z32` converts z32 pubkey to age Recipient with round-trip test proving correctness. `delete_record` sends HTTP DELETE with 404-as-success idempotency. `list_record_tokens` parses directory listing and filters out "latest".
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend CLI with --share, --burn flags and List/Revoke subcommands</name>
  <files>src/cli.rs, src/commands/mod.rs, src/main.rs, src/error.rs</files>
  <action>
1. Add `--share` and `--burn` flags to the top-level `Cli` struct in `src/cli.rs`:
   ```rust
   /// Encrypt for a specific recipient's z32-encoded public key
   #[arg(long, value_name = "PUBKEY")]
   pub share: Option<String>,

   /// Mark as burn-after-read (deleted after first successful pickup)
   #[arg(long)]
   pub burn: bool,
   ```
   These are publish-time flags that sit alongside `session_id`, `ttl`, and `qr`.

2. Add `List` and `Revoke` subcommands to the `Commands` enum:
   ```rust
   /// List all active handoff records on the homeserver
   List,
   /// Revoke (delete) a handoff record from the homeserver
   Revoke(RevokeArgs),
   ```

3. Add `RevokeArgs` struct:
   ```rust
   #[derive(Parser)]
   pub struct RevokeArgs {
       /// Token of the handoff to revoke
       #[arg(value_name = "TOKEN")]
       pub token: Option<String>,

       /// Revoke all active handoffs
       #[arg(long)]
       pub all: bool,

       /// Skip confirmation prompt
       #[arg(long, short = 'y')]
       pub yes: bool,
   }
   ```

4. Add stub modules in `src/commands/`:
   - Create `src/commands/list.rs` with: `pub fn run_list() -> anyhow::Result<()> { todo!() }`
   - Create `src/commands/revoke.rs` with: `pub fn run_revoke(_args: crate::cli::RevokeArgs) -> anyhow::Result<()> { todo!() }`

5. Register new modules in `src/commands/mod.rs`:
   ```rust
   pub mod init;
   pub mod list;
   pub mod pickup;
   pub mod publish;
   pub mod revoke;
   pub mod whoami;
   ```

6. Wire new subcommands in `src/main.rs` match:
   ```rust
   Some(Commands::List) => commands::list::run_list()?,
   Some(Commands::Revoke(args)) => commands::revoke::run_revoke(args)?,
   ```

7. Verify: `cargo check` passes. `cclink --help` shows --share, --burn. `cclink list --help` and `cclink revoke --help` show correct args.
  </action>
  <verify>
    `cargo check` passes. `cargo test` passes (all existing tests, stubs compile but are not called in tests).
  </verify>
  <done>
    CLI accepts `--share <PUBKEY>`, `--burn`, subcommands `list` and `revoke <TOKEN>` / `revoke --all`. Stub implementations compile. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo test` — all existing tests pass (record: 8+, crypto: 7+, transport: 9+, session, pickup: 4)
2. `cargo check` — clean compilation with no warnings
3. `cclink --help` — shows --share, --burn, --ttl, --qr, and subcommands init, whoami, pickup, list, revoke
4. `cclink revoke --help` — shows TOKEN positional, --all, --yes/-y flags
5. New record backwards-compat test verifies Phase 3 record deserialization + verification
</verification>

<success_criteria>
All Phase 4 primitives are in place: HandoffRecord extended, crypto helper added, transport DELETE/LIST methods added, CLI wired. Zero regressions in existing tests. Plans 04-02 and 04-03 can proceed independently using these primitives.
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-encryption-and-management/04-01-SUMMARY.md`
</output>
