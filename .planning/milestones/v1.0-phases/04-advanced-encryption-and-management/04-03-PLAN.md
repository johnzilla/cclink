---
phase: 04-advanced-encryption-and-management
plan: 03
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/commands/list.rs
  - src/commands/revoke.rs
autonomous: true
requirements:
  - MGT-01
  - MGT-02
  - MGT-03

must_haves:
  truths:
    - "User runs cclink list and sees a table with token, project, age, TTL remaining, burn status, and recipient for each active record"
    - "Expired records are excluded from the list"
    - "Empty state shows friendly message"
    - "User runs cclink revoke <token> and sees record details, confirms, then record is deleted"
    - "User runs cclink revoke --all and sees count, confirms, then all records are deleted"
    - "cclink revoke --yes skips confirmation"
  artifacts:
    - path: "src/commands/list.rs"
      provides: "cclink list command with comfy-table output"
      contains: "comfy_table"
    - path: "src/commands/revoke.rs"
      provides: "cclink revoke command with confirmation prompts"
      contains: "delete_record"
  key_links:
    - from: "src/commands/list.rs"
      to: "src/transport/mod.rs"
      via: "list_record_tokens + get_record to fetch all records"
      pattern: "list_record_tokens"
    - from: "src/commands/revoke.rs"
      to: "src/transport/mod.rs"
      via: "delete_record for single and batch revocation"
      pattern: "delete_record"
---

<objective>
Implement `cclink list` and `cclink revoke` management commands for viewing and deleting published handoff records.

Purpose: Delivers MGT-01 (list active records), MGT-02 (revoke single record), and MGT-03 (revoke all records). Users need visibility and control over their published handoffs.

Output: Two new command modules (list.rs, revoke.rs) replacing the stub implementations from 04-01.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-encryption-and-management/04-RESEARCH.md
@.planning/phases/04-advanced-encryption-and-management/04-CONTEXT.md
@.planning/phases/04-advanced-encryption-and-management/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cclink list command</name>
  <files>src/commands/list.rs</files>
  <action>
Replace the `todo!()` stub in `src/commands/list.rs` with the full list implementation.

1. Function signature: `pub fn run_list() -> anyhow::Result<()>`

2. Load keypair and homeserver:
   ```rust
   let keypair = crate::keys::store::load_keypair()?;
   let homeserver = crate::keys::store::read_homeserver()?;
   let client = crate::transport::HomeserverClient::new(&homeserver)?;
   ```

3. Sign in and list tokens:
   ```rust
   client.signin(&keypair)?;
   let tokens = client.list_record_tokens()?;
   ```

4. If no tokens, print friendly empty state and return:
   ```rust
   if tokens.is_empty() {
       println!("{}", "No active handoffs. Publish one with cclink."
           .if_supports_color(Stdout, |t| t.yellow()));
       return Ok(());
   }
   ```

5. Fetch each record, filter expired ones, collect into a Vec of (token, HandoffRecord) tuples:
   ```rust
   let now_secs = std::time::SystemTime::now()
       .duration_since(std::time::SystemTime::UNIX_EPOCH)
       .map(|d| d.as_secs())
       .unwrap_or(0);

   let mut active_records: Vec<(String, crate::record::HandoffRecord)> = Vec::new();
   for token in &tokens {
       match client.get_record(token, &keypair.public_key()) {
           Ok(record) => {
               let expires_at = record.created_at.saturating_add(record.ttl);
               if now_secs < expires_at {
                   active_records.push((token.clone(), record));
               }
           }
           Err(_) => {
               // Skip records that fail to fetch or verify — they may have been
               // tampered with or partially written. Silent skip is correct.
               continue;
           }
       }
   }
   ```

6. If no active records after filtering, print empty state:
   ```rust
   if active_records.is_empty() {
       println!("{}", "No active handoffs. Publish one with cclink."
           .if_supports_color(Stdout, |t| t.yellow()));
       return Ok(());
   }
   ```

7. Build comfy-table for display per CONTEXT.md columns: token (truncated), project, age, TTL remaining, burn flag, recipient pubkey:
   ```rust
   use comfy_table::{Table, Cell, Color};

   let mut table = Table::new();
   table.set_header(vec!["Token", "Project", "Age", "TTL Left", "Burn", "Recipient"]);

   for (token, record) in &active_records {
       let token_display = if token.len() > 8 { &token[..8] } else { token.as_str() };
       let age_secs = now_secs.saturating_sub(record.created_at);
       let ttl_left = record.created_at.saturating_add(record.ttl).saturating_sub(now_secs);
       let burn_display = if record.burn { "yes" } else { "" };
       let recipient_display = record.recipient.as_deref().unwrap_or("");
       let recipient_short = if recipient_display.len() > 8 {
           &recipient_display[..8]
       } else {
           recipient_display
       };

       table.add_row(vec![
           Cell::new(token_display),
           Cell::new(&record.project),
           Cell::new(&human_duration(age_secs)),
           Cell::new(&human_duration(ttl_left)),
           if record.burn {
               Cell::new(burn_display).fg(Color::Yellow)
           } else {
               Cell::new(burn_display)
           },
           Cell::new(recipient_short),
       ]);
   }
   println!("{table}");
   ```

8. Add a private `human_duration` helper in this module (same logic as pickup.rs — both are module-private, not shared):
   ```rust
   fn human_duration(secs: u64) -> String {
       if secs >= 3600 { format!("{}h", secs / 3600) }
       else if secs >= 60 { format!("{}m", secs / 60) }
       else { format!("{}s", secs) }
   }
   ```

9. Use owo-colors imports: `use owo_colors::{OwoColorize, Stream::Stdout};`

10. Verify: `cargo check` passes. The list command fetches tokens, fetches records, filters expired, renders table.
  </action>
  <verify>
    `cargo check` passes. Code inspection confirms: sign in, list tokens, fetch each record, filter expired, render comfy-table with all required columns. Empty state handled.
  </verify>
  <done>
    `cclink list` shows a colored table with token (truncated), project, age, TTL remaining, burn status, and recipient pubkey for all active (non-expired) records. Empty state prints friendly message.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cclink revoke command</name>
  <files>src/commands/revoke.rs</files>
  <action>
Replace the `todo!()` stub in `src/commands/revoke.rs` with the full revoke implementation.

1. Function signature: `pub fn run_revoke(args: crate::cli::RevokeArgs) -> anyhow::Result<()>`

2. Load keypair, homeserver, create client, sign in:
   ```rust
   let keypair = crate::keys::store::load_keypair()?;
   let homeserver = crate::keys::store::read_homeserver()?;
   let client = crate::transport::HomeserverClient::new(&homeserver)?;
   client.signin(&keypair)?;
   ```

3. Validate args: either `args.token` or `args.all` must be specified, not neither:
   ```rust
   if args.token.is_none() && !args.all {
       anyhow::bail!("Provide a token to revoke, or use --all to revoke all handoffs.");
   }
   ```

4. Handle `--all` mode (MGT-03):
   ```rust
   if args.all {
       let tokens = client.list_record_tokens()?;
       if tokens.is_empty() {
           println!("No active handoffs.");
           return Ok(());
       }
       let count = tokens.len();
       let skip_confirm = args.yes || !std::io::stdin().is_terminal();
       if !skip_confirm {
           let confirmed = dialoguer::Confirm::new()
               .with_prompt(format!(
                   "This will revoke {} active handoff{}. Continue?",
                   count,
                   if count == 1 { "" } else { "s" }
               ))
               .default(false)
               .interact()
               .map_err(|e| anyhow::anyhow!("prompt failed: {}", e))?;
           if !confirmed {
               println!("Aborted.");
               return Ok(());
           }
       }
       for token in &tokens {
           client.delete_record(token)?;
       }
       println!(
           "{}",
           format!("Revoked {} handoff{}.", count, if count == 1 { "" } else { "s" })
               .if_supports_color(Stdout, |t| t.green())
       );
       return Ok(());
   }
   ```

5. Handle single-token revoke (MGT-02):
   ```rust
   let token = args.token.as_ref().unwrap(); // Safe: validated above

   // Fetch the record to show details in the confirmation prompt
   match client.get_record(token, &keypair.public_key()) {
       Ok(record) => {
           let token_prefix = if token.len() > 8 { &token[..8] } else { token.as_str() };
           let skip_confirm = args.yes || !std::io::stdin().is_terminal();
           if !skip_confirm {
               let confirmed = dialoguer::Confirm::new()
                   .with_prompt(format!(
                       "Revoke handoff {}... ({})?",
                       token_prefix, record.project
                   ))
                   .default(false)
                   .interact()
                   .map_err(|e| anyhow::anyhow!("prompt failed: {}", e))?;
               if !confirmed {
                   println!("Aborted.");
                   return Ok(());
               }
           }
           client.delete_record(token)?;
           println!(
               "{} {} ({})",
               "Revoked.".if_supports_color(Stdout, |t| t.green()),
               token_prefix,
               record.project
           );
       }
       Err(_) => {
           // Record not found or verification failed — try deleting anyway
           // (might be a corrupted record the user still wants removed)
           let skip_confirm = args.yes || !std::io::stdin().is_terminal();
           if !skip_confirm {
               let token_prefix = if token.len() > 8 { &token[..8] } else { token.as_str() };
               let confirmed = dialoguer::Confirm::new()
                   .with_prompt(format!(
                       "Record {}... not found or corrupt. Delete anyway?",
                       token_prefix
                   ))
                   .default(false)
                   .interact()
                   .map_err(|e| anyhow::anyhow!("prompt failed: {}", e))?;
               if !confirmed {
                   println!("Aborted.");
                   return Ok(());
               }
           }
           client.delete_record(token)?;
           println!(
               "{}",
               "Revoked.".if_supports_color(Stdout, |t| t.green())
           );
       }
   }
   ```

6. Use imports:
   ```rust
   use std::io::IsTerminal;
   use owo_colors::{OwoColorize, Stream::Stdout};
   ```

7. Verify: `cargo check` passes. `cargo test` passes.
  </action>
  <verify>
    `cargo check` passes. `cargo test` passes. Code inspection confirms: single-token revoke shows details + confirm; --all shows count + confirm; --yes skips confirmation; success uses green "Revoked." output.
  </verify>
  <done>
    `cclink revoke <token>` shows record details and confirms before deletion. `cclink revoke --all` shows blast-radius count and confirms. `--yes/-y` skips prompts. Green success output matches existing publish style.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` — clean compilation
2. `cargo test` — all tests pass
3. `cclink list --help` — shows correct description
4. `cclink revoke --help` — shows TOKEN positional, --all, --yes/-y
5. Code review: list fetches tokens, filters expired, renders comfy-table with all required columns
6. Code review: revoke handles single-token and --all with confirmation prompts
7. Code review: empty states handled gracefully with friendly messages
</verification>

<success_criteria>
`cclink list` displays a colored table of active records with all specified columns. `cclink revoke <token>` and `cclink revoke --all` delete records with confirmation prompts. Empty states show friendly messages. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-encryption-and-management/04-03-SUMMARY.md`
</output>
