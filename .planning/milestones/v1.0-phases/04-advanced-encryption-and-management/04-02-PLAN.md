---
phase: 04-advanced-encryption-and-management
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/commands/publish.rs
  - src/commands/pickup.rs
autonomous: true
requirements:
  - ENC-01
  - ENC-02

must_haves:
  truths:
    - "User runs cclink --share <z32_pubkey> and the session is encrypted to the recipient's X25519 key, not the publisher's"
    - "User runs cclink --burn and the record is published with burn flag; yellow warning displayed"
    - "cclink --burn --share <pubkey> combines both features in one record"
    - "Recipient picks up a --share record and decrypts it with their own key"
    - "Self-pickup of a --burn record triggers inline DELETE after successful decryption"
    - "Wrong-recipient pickup shows clear error with cleartext metadata (project, hostname, age)"
  artifacts:
    - path: "src/commands/publish.rs"
      provides: "Publish with --share and --burn support"
      contains: "recipient_from_z32"
    - path: "src/commands/pickup.rs"
      provides: "Pickup with shared record handling and burn-after-read"
      contains: "delete_record"
  key_links:
    - from: "src/commands/publish.rs"
      to: "src/crypto/mod.rs"
      via: "recipient_from_z32 for --share encryption"
      pattern: "crypto::recipient_from_z32"
    - from: "src/commands/pickup.rs"
      to: "src/transport/mod.rs"
      via: "delete_record for burn-after-read"
      pattern: "client\\.delete_record"
---

<objective>
Implement `--share` and `--burn` flags in the publish command, and extend pickup to handle shared-record decryption and burn-after-read deletion.

Purpose: Delivers ENC-01 (share with specific recipient) and ENC-02 (burn-after-read). These are the two advanced encryption features that differentiate cclink from a simple session relay.

Output: Extended publish.rs and pickup.rs with full --share and --burn support.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-encryption-and-management/04-RESEARCH.md
@.planning/phases/04-advanced-encryption-and-management/04-CONTEXT.md
@.planning/phases/04-advanced-encryption-and-management/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend publish command with --share and --burn support</name>
  <files>src/commands/publish.rs</files>
  <action>
1. Modify the encryption step (section 4) in `run_publish()` to handle `--share`:
   ```rust
   let recipient = if let Some(ref share_pubkey) = cli.share {
       // Encrypt to the specified recipient's X25519 key (ENC-01)
       crate::crypto::recipient_from_z32(share_pubkey)?
   } else {
       // Self-encrypt to own X25519 key (existing behavior)
       let x25519_pubkey = crate::crypto::ed25519_to_x25519_public(&keypair);
       crate::crypto::age_recipient(&x25519_pubkey)
   };
   let ciphertext = crate::crypto::age_encrypt(session.session_id.as_bytes(), &recipient)?;
   ```

2. Set the `burn` and `recipient` fields when building the HandoffRecord (section 5):
   - `burn: cli.burn`
   - `recipient: cli.share.clone()`
   These fields are NOT in HandoffRecordSignable (per 04-01 decision), so no change to the signable construction.

3. Add yellow burn warning in the output section (section 7), BEFORE the "Published!" message:
   ```rust
   if cli.burn {
       println!(
           "{}",
           "Warning: This handoff will be deleted after the first successful pickup."
               .if_supports_color(Stdout, |t| t.yellow())
       );
   }
   ```

4. Update the pickup command instruction in success output to show the correct pickup syntax:
   - If `--share` was used, the pickup command should hint at the publisher's pubkey:
     ```rust
     if cli.share.is_some() {
         // Shared: recipient needs to specify the publisher's pubkey
         let own_pubkey = keypair.public_key().to_z32();
         println!("  Recipient pickup command:");
         println!(
             "  {}",
             format!("cclink pickup {}", own_pubkey).if_supports_color(Stdout, |t| t.bold())
         );
     } else {
         // Self: existing pickup command
         println!("  Run on another machine:");
         println!(
             "  {}",
             format!("cclink pickup {}", token).if_supports_color(Stdout, |t| t.bold())
         );
     }
     ```
   - Note: the recipient does `cclink pickup <publisher_pubkey>`, which triggers the cross-user path and reads the publisher's latest record.

5. Verify: `cargo check` passes. Test manually by reading the code path — the publish flow should construct HandoffRecord with correct burn/recipient fields.
  </action>
  <verify>
    `cargo check` passes. `cargo test` passes (all existing tests). Code inspection confirms: --share selects recipient_from_z32 path; --burn sets burn field; output includes yellow warning for burn; shared publish shows recipient pickup command.
  </verify>
  <done>
    `cclink --share <z32_pubkey>` encrypts to recipient's X25519 key. `cclink --burn` sets burn flag with yellow warning. `cclink --burn --share <pubkey>` combines both. Success output shows correct pickup instructions for each mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend pickup command with shared-record handling and burn-after-read</name>
  <files>src/commands/pickup.rs</files>
  <action>
1. After the TTL check (section 3) and before decryption (section 4), add recipient detection logic:
   - Check `record.recipient` field:
     - If `record.recipient.is_some()` AND the pickup is self-pickup (no pubkey arg):
       This means the user is the PUBLISHER trying to pick up their own --share record, which they cannot decrypt (it was encrypted to the recipient's key, not their own). Show an error:
       ```rust
       if let Some(ref intended_recipient) = record.recipient {
           if !is_cross_user {
               // Publisher trying to pick up their own --share record — cannot decrypt
               eprintln!(
                   "{}",
                   format!(
                       "Error: This handoff was shared with {}. Only the recipient can decrypt it.",
                       intended_recipient
                   ).if_supports_color(Stdout, |t| t.red())
               );
               println!("  Host: {}", record.hostname);
               println!("  Project: {}", record.project);
               println!("  Created: {} ago", human_age);
               return Ok(());
           }
       }
       ```

   - If `record.recipient.is_some()` AND the pickup IS cross-user (pubkey arg provided):
     The person picking up may or may not be the intended recipient. Attempt decryption with their own key. If it fails, show metadata with a clear message:
     Modify the existing cross-user branch to attempt decryption when `record.recipient` matches the picker's own pubkey. Otherwise, show the "wrong recipient" error with cleartext metadata per CONTEXT.md decision.

2. Rework the cross-user vs self-pickup decryption in section 4:
   Replace the current hard split (cross-user = show metadata only, self = decrypt) with a more nuanced flow:

   ```rust
   if is_cross_user {
       // Cross-user pickup: attempt decryption with own key
       let ciphertext = base64::engine::general_purpose::STANDARD
           .decode(&record.blob)
           .map_err(|e| anyhow::anyhow!("failed to decode blob: {}", e))?;
       let x25519_secret = crate::crypto::ed25519_to_x25519_secret(&keypair);
       let identity = crate::crypto::age_identity(&x25519_secret);

       match crate::crypto::age_decrypt(&ciphertext, &identity) {
           Ok(plaintext) => {
               // Decryption succeeded — this record was shared WITH us
               let session_id = String::from_utf8(plaintext)
                   .map_err(|e| anyhow::anyhow!("session ID is not valid UTF-8: {}", e))?;
               // Continue to confirmation + exec (shared flow below)
               // ... (proceed to confirm + burn-delete + exec)
           }
           Err(_) => {
               // Cannot decrypt — show cleartext metadata per CONTEXT.md
               println!(
                   "Handoff from {}",
                   record.pubkey.if_supports_color(Stdout, |t| t.cyan())
               );
               println!("  Host: {}", record.hostname.if_supports_color(Stdout, |t| t.cyan()));
               println!("  Project: {}", record.project.if_supports_color(Stdout, |t| t.cyan()));
               println!("  Created: {} ago", human_age);
               if record.recipient.is_some() {
                   println!(
                       "{}",
                       "This handoff was encrypted for a specific recipient. Your key cannot decrypt it."
                           .if_supports_color(Stdout, |t| t.yellow())
                   );
               } else {
                   println!(
                       "{}",
                       "This handoff is self-encrypted. Only the publisher can decrypt it."
                           .if_supports_color(Stdout, |t| t.yellow())
                   );
               }
               return Ok(());
           }
       }
   }
   ```

   For the self-pickup path (no pubkey arg): keep existing decryption logic unchanged (decrypt with own key, which works for self-encrypted records).

3. After successful decryption (both self and cross-user shared), add burn-after-read deletion:
   ```rust
   // Burn-after-read: delete record from homeserver after successful decryption
   if record.burn {
       // Only attempt DELETE if this is self-pickup (we have auth to delete our own records)
       // For cross-user pickup, the recipient cannot DELETE the publisher's record
       if !is_cross_user {
           if let Err(e) = client.delete_record(&token) {
               eprintln!(
                   "{}",
                   format!("Warning: burn deletion failed: {}", e)
                       .if_supports_color(Stdout, |t| t.yellow())
               );
           }
       }
       // Note: for shared records picked up cross-user, burn cannot be enforced
       // by the recipient. The record will expire via TTL.
   }
   ```
   This goes after decryption succeeds but before the confirmation prompt. The DELETE must happen BEFORE the user execs claude (which replaces the process).

   Wait — on self-pickup, signin() was already called in the retry block. The session cookie is on the client. So delete_record should work. But there is a subtlety: the token variable. In the current code, `token` is extracted from the `latest` pointer inside the retry closure. We need to capture it outside the closure.

   Look at the current code: `latest.token` is used inside the retry closure. The `record` is returned from the closure but not the token. We need to also return the token from the retry closure, or extract it from `record.created_at.to_string()` (which is how tokens work — token = created_at as string).

   Use: `let token = record.created_at.to_string();` after the record is returned from retry. This matches the token derivation pattern established in transport::publish().

4. Refactor the code to avoid duplication between self-pickup and cross-user-shared-pickup paths. Both paths need: decryption -> burn check -> confirm -> QR -> exec. Extract the shared logic into a helper or use a single `session_id` variable that both paths populate, then converge on the common tail (burn + confirm + QR + exec).

   Suggested structure:
   ```rust
   let session_id: String;
   let token = record.created_at.to_string();

   if is_cross_user {
       // Attempt decryption with own key
       match decrypt_attempt {
           Ok(plaintext) => { session_id = ...; }
           Err(_) => { show_metadata(); return Ok(()); }
       }
   } else {
       // Check for own --share record (cannot decrypt)
       if record.recipient.is_some() { show_error(); return Ok(()); }
       // Self-decrypt
       session_id = ...;
   }

   // Common path: burn + confirm + QR + exec
   if record.burn && !is_cross_user {
       client.delete_record(&token)...;
   }
   // confirm, QR, exec (existing code)
   ```

5. Verify: `cargo check` passes. `cargo test` passes (existing pickup tests for human_duration are unaffected).
  </action>
  <verify>
    `cargo check` passes. `cargo test` passes. Code inspection confirms: cross-user pickup of shared record attempts decryption; wrong-recipient shows metadata with error; burn-after-read triggers DELETE on self-pickup; burn + shared records rely on TTL for expiry (documented limitation).
  </verify>
  <done>
    Pickup handles all four scenarios: (1) self-pickup of self-encrypted record (existing), (2) self-pickup of own --share record (error: only recipient can decrypt), (3) cross-user pickup of shared record (decrypt with own key), (4) cross-user pickup of non-shared record (show metadata). Burn-after-read deletes on self-pickup; logs warning on failure; skips for cross-user (cannot auth).
  </done>
</task>

</tasks>

<verification>
1. `cargo check` — clean compilation
2. `cargo test` — all tests pass including existing pickup::tests
3. Code review: publish.rs uses recipient_from_z32 when --share is set
4. Code review: pickup.rs attempts decryption for cross-user --share, shows metadata on failure
5. Code review: burn DELETE happens after decrypt, before confirm/exec, only on self-pickup
6. Code review: yellow warning printed on burn publish
</verification>

<success_criteria>
`--share <pubkey>` encrypts to recipient's key and shows correct pickup instructions. `--burn` sets the burn flag and deletes the record after first self-pickup. The four pickup scenarios (self/self-shared/cross-shared/cross-unshared) are handled with appropriate decryption and messaging.
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-encryption-and-management/04-02-SUMMARY.md`
</output>
